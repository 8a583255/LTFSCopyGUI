<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Diagnostics.Runtime</name>
    </assembly>
    <members>
        <member name="T:Microsoft.Diagnostics.Runtime.AbstractDac.IAbstractClrNativeHeaps">
             <summary>
             Enumerates tracked native memory that the CLR has allocated.
            
             This interface is optional.
            
             This interface is not "stable" and may change even in minor or patch
             versions of ClrMD.
             </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.AbstractDac.IAbstractComHelpers">
             <summary>
             Helpers for COM information.
            
             This interface is optional.
            
             This interface is not "stable" and may change even in minor or patch
             versions of ClrMD.
             </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.AbstractDac.IAbstractDacController">
             <summary>
             Interface to control the target dac/debugging layer.
            
             This interface is optional, but if not present the library
             will assume this dac is not thread safe and cannot flush
             cahed data.
            
             This interface is not "stable" and may change even in minor or patch
             versions of ClrMD.
             </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.IAbstractDacController.IsThreadSafe">
            <summary>
            Whether all methods on all abstract dac APIs are thread
            safe or not.  If <see cref="P:Microsoft.Diagnostics.Runtime.AbstractDac.IAbstractDacController.IsThreadSafe"/> returns false, we will
            not allow any multithreaded use of ClrMD.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.IAbstractDacController.CanFlush">
            <summary>
            Whether the library supports flushing cached data.  The
            <see cref="M:Microsoft.Diagnostics.Runtime.AbstractDac.IAbstractDacController.Flush"/> method will only be called if <see cref="P:Microsoft.Diagnostics.Runtime.AbstractDac.IAbstractDacController.CanFlush"/>
            returns true.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.AbstractDac.IAbstractDacController.Flush">
            <summary>
            Flushes any built up caches of data reads within the dac.  This
            is typically called in a live debugging operation after the state
            of the process is changed (e.g. after stepping in the debugger)
            to ensure we aren't reading stale data.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.AbstractDac.IAbstractHeap">
             <summary>
             This interface is used to construct the ClrHeap object and is required
             because ClrHeap is the parent of all ClrTypes.
            
             This interface is required.
            
             This interface is not "stable" and may change even in minor or patch
             versions of ClrMD.
             </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.AbstractDac.IAbstractLegacyThreadPool">
             <summary>
             Gives information about the native ThreadPool in the .Net Runtime.
             Modern runtimes use the C# based ThreadPool, or the Windows OS
             ThreadPool and not the old CLR native one.
            
             This interface is optional.
            
             This interface is not "stable" and may change even in minor or patch
             versions of ClrMD.
             </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.AbstractDac.IAbstractMethodLocator">
             <summary>
             This interface is used to link methods to their parent types
             and instruction pointers to methods.
            
             This interface is optional.
            
             This interface is not "stable" and may change even in minor or patch
             versions of ClrMD.
             </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.AbstractDac.IAbstractModuleHelpers">
             <summary>
             Used to construct ClrModules.
            
             This interface is required.
            
             This interface is not "stable" and may change even in minor or patch
             versions of ClrMD.
             </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.AbstractDac.IAbstractRuntime">
             <summary>
             The base interface for building an abstract ClrRuntime.
            
             This interface is required.  We need to be able to at least
             enumerate AppDomains and modules to construct a ClrRuntime.
             If the target version of CLR does not support AppDomains,
             this API needs to produce a single "AppDomainInfo" to use
             as a pseudo-AppDomain.
            
             This interface is not "stable" and may change even in minor or patch
             versions of ClrMD.
             </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.AbstractDac.ClrThreadInfo">
            <summary>
            Information about a single coreclr!Thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.ClrThreadInfo.Address">
            <summary>
            The address of the underlying coreclr!Thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.ClrThreadInfo.AppDomain">
            <summary>
            The AppDomain that this thread is currently running in.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.ClrThreadInfo.OSThreadId">
            <summary>
            The thread ID as the Operating System sees it.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.ClrThreadInfo.ManagedThreadId">
            <summary>
            The managed thread id.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.ClrThreadInfo.LockCount">
            <summary>
            The lock count of the Thread, if available.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.ClrThreadInfo.Teb">
            <summary>
            The Windows TEB, if available, 0 otherwise.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.ClrThreadInfo.StackBase">
            <summary>
            The base address range of the stack space for this thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.ClrThreadInfo.StackLimit">
            <summary>
            The limit of the stack space for this thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.ClrThreadInfo.ExceptionInFlight">
            <summary>
            If an exception is in flight on this thread, a pointer directly to
            the exception object itself.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.ClrThreadInfo.IsFinalizer">
            <summary>
            Whether this thread is a finalizer thread or not.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.ClrThreadInfo.IsGC">
            <summary>
            Whether this thread is a GC thread or not.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.ClrThreadInfo.GCMode">
            <summary>
            The GCMode of this thread (cooperative, preemptive).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.ClrThreadInfo.State">
            <summary>
            The state of this thread.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.AbstractDac.AppDomainInfo">
            <summary>
            Information about a single app domain.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.AppDomainInfo.Address">
            <summary>
            The address of coreclr!AppDomain
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.AppDomainInfo.Kind">
            <summary>
            The kind of AppDomain.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.AppDomainInfo.Id">
            <summary>
            The AppDomain's Id.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.AppDomainInfo.Name">
            <summary>
            The name of the AppDomain.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.AppDomainInfo.ConfigFile">
            <summary>
            The ConfigFile associated with this AppDomain (or null if there isn't one).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.AppDomainInfo.ApplicationBase">
            <summary>
            The path associated with this AppDomain (or null if not available in this runtime).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.AppDomainInfo.LoaderAllocator">
            <summary>
            The LoaderAllocator pointer for this AppDomain.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.AbstractDac.ClrHandleInfo">
            <summary>
            Information about a ClrHandle
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.ClrHandleInfo.Address">
            <summary>
            The address of the handle.  AKA the handle itself.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.ClrHandleInfo.Object">
            <summary>
            The object this handle points to.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.ClrHandleInfo.Kind">
            <summary>
            The kind of handle.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.ClrHandleInfo.AppDomain">
            <summary>
            The AppDomain this handle lives in.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.ClrHandleInfo.DependentTarget">
            <summary>
            The dependent handle target, only valid for Kind == Dependent.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.ClrHandleInfo.RefCount">
            <summary>
            The RefCount of a reference count handle.  Only valid for Kind == Dependent.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.AbstractDac.JitManagerInfo">
            <summary>
            Information about a single JitManager.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.JitManagerInfo.Address">
            <summary>
            The address of the JitManager.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.JitManagerInfo.Kind">
            <summary>
            The kind of code heap this JitManager contains.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.JitManagerInfo.HeapList">
            <summary>
            The location of the heap list.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.AbstractDac.IAbstractThreadHelpers">
             <summary>
             Helpers for ClrThreads.
            
             This interface is optional, but without it we cannot enumerate
             stack traces or roots.
            
             This interface is not "stable" and may change even in minor or patch
             versions of ClrMD.
             </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.AbstractDac.IAbstractThreadHelpers.EnumerateStackRoots(System.UInt32,System.Boolean)">
            <summary>
            Enumerates the roots of this thread.
            </summary>
            <param name="osThreadId">The thread to enumerate.</param>
            <param name="traceErrors">Whether or not to Trace any errors encountered.</param>
            <returns>An enumeration of stack roots.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.AbstractDac.IAbstractThreadHelpers.EnumerateStackTrace(System.UInt32,System.Boolean,System.Boolean)">
            <summary>
            Enumerates the stack trace of this method.  Note that in the event of bugs or corrupted
            state, this can occasionally produce bad data and run "forever", so be sure to break out of
            the loop when a threshold is reached when calling it.
            </summary>
            <param name="osThreadId">The thread to enumerate.</param>
            <param name="includeContext">Whether to calculate and include the thread's CONTEXT record or not.
            Registers are always in the Windows CONTEXT format, as that's what the OS uses.</param>
            <param name="traceErrors">Whether or not to Trace any errors encountered.</param>
            <returns>An enumeration of stack frames.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.AbstractDac.StackFrameInfo">
            <summary>
            Information about a single stack frame in a stack trace.  This can be a real stack frame as the OS sees
            it, or a clr!Frame marker on the stack (internal frame).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.StackFrameInfo.InstructionPointer">
            <summary>
            The IP of this frame.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.StackFrameInfo.StackPointer">
            <summary>
            The SP of this frame.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.StackFrameInfo.IsInternalFrame">
            <summary>
            Whether or not this is a clr!Frame or not.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.StackFrameInfo.InternalFrameVTable">
            <summary>
            The VTable of the Frame.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.StackFrameInfo.InternalFrameName">
            <summary>
            The name of the Frame, if available.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.StackFrameInfo.InnerMethodMethodHandle">
            <summary>
            Some clr!Frames have a managed method associated with it.  This is
            the method handle (usually MethodDesc) associated with it.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.StackFrameInfo.Context">
            <summary>
            The thread's CONTEXT record, if requested.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.AbstractDac.StackRootInfo">
            <summary>
            Information about a single root on the stack.  For this to work properly, we need
            these things to be true:
                OS Stack Frames - IP and SP should match what the OS stack unwinder says where this
                                  stack frame is.
                coreclr!Frames  - The StackPointer or the InternalFrame must match the direct
                                  pointer to the clr!Frame object
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.StackRootInfo.InstructionPointer">
            <summary>
            The IP associated with this root.  This may be 0 if the root comes from a
            clr!Frame.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.StackRootInfo.StackPointer">
            <summary>
            The StackPointer associated with this root.  This may be the SP of the actual
            OS frame on the stack or it may be the pointer of the data on the stack.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.StackRootInfo.InternalFrame">
            <summary>
            The coreclr!Frame this root came from, or 0.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.StackRootInfo.IsInterior">
            <summary>
            Whether the pointer is "interior" or not.  Interior pointers need not point
            to the beginning of the object, and don't even need to point to the GC heap.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.StackRootInfo.IsPinned">
            <summary>
            Whether the pointer is pinned or not.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.StackRootInfo.Address">
            <summary>
            The address of the stack slot this root is contained in (maybe 0 if the object is
            enregistered).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.StackRootInfo.Object">
            <summary>
            A pointer to the object itself.  This pointer may not point to the beginning of an
            object, or even to the GC heap itself if IsInterior == true.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.StackRootInfo.IsEnregistered">
            <summary>
            Whether this root is in the thread's register CONTEXT for the frame.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.StackRootInfo.RegisterName">
            <summary>
            The register name, if available.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.StackRootInfo.RegisterOffset">
            <summary>
            The offset from the register.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.AbstractDac.IAbstractTypeHelpers">
             <summary>
             Provides information about types, fields, and methods.
            
             This interface is required, but some methods can return default values.
            
             This interface is not "stable" and may change even in minor or patch
             versions of ClrMD.
             </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AbstractDac.ObjectArrayInformation.DataPointer">
            <summary>
            The location of the first element in the array.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.CacheOptions.CacheStackTraces">
            <summary>
            Whether to cache stack traces or not.  This can take up significant memory in
            larger dump files, but will vastly improve performance if the application needs to
            walk stacks multiple times.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.CacheOptions.MaxDumpCacheSize">
            <summary>
            The maximum amount of memory (virtual address space) used by data readers to cache
            memory from the dumpfile.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.CacheOptions.UseOSMemoryFeatures">
            <summary>
            Whether or not to attempt to use special OS memory features such as AWE on
            Windows.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrAppDomain">
            <summary>
            Represents an AppDomain in the target runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.Runtime">
            <summary>
            Gets the runtime associated with this ClrAppDomain.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.Address">
            <summary>
            Gets address of the AppDomain.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.Id">
            <summary>
            Gets the AppDomain's ID.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.Name">
            <summary>
            Gets the name of the AppDomain, as specified when the domain was created.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.Modules">
            <summary>
            Gets a list of modules loaded into this AppDomain.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.ConfigurationFile">
            <summary>
            Gets the config file used for the AppDomain.  This may be <see langword="null"/> if there was no config file
            loaded, or if the targeted runtime does not support enumerating that data.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.ApplicationBase">
            <summary>
            Gets the base directory for this AppDomain.  This may return <see langword="null"/> if the targeted runtime does
            not support enumerating this information.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.LoaderAllocator">
            <summary>
            Returns the LoaderAllocator for this AppDomain.  This is used to debug some CLR internal state
            and isn't generally useful for most developers.  This field is only available when debugging
            .Net 8+ runtimes.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrAppDomain.EnumerateLoaderAllocatorHeaps">
            <summary>
            Enumerates the native heaps associated with this AppDomain.  Note that this may also enumerate
            the same heaps as other domains if they share the same LoaderAllocator (especially SystemDomain).
            </summary>
            <returns>An enumerable of native heaps associated with this AppDomain.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrAppDomain.ToString">
            <summary>
            To string override.
            </summary>
            <returns>The name of this AppDomain.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrArray">
            <summary>
            Represents an array in the target process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrArray.Address">
            <summary>
            Gets the address of the object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrArray.Type">
            <summary>
            Gets the type of the object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrArray.Length">
            <summary>
            Gets the count of elements in this array.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrArray.ReadValues``1(System.Int32,System.Int32)">
            <summary>
            Gets <paramref name="count"/> element values from the array.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrArray.Equals(System.Object)">
            <summary>
            Determines whether this instance and another specific <see cref="T:Microsoft.Diagnostics.Runtime.ClrArray"/> have the same value.
            <para>Instances are considered equal when they have the same <see cref="P:Microsoft.Diagnostics.Runtime.ClrArray.Address"/>.</para>
            </summary>
            <param name="obj">The <see cref="T:Microsoft.Diagnostics.Runtime.ClrArray"/> to compare to this instance.</param>
            <returns><see langword="true"/> if the <see cref="P:Microsoft.Diagnostics.Runtime.ClrArray.Address"/> of the parameter is the same as <see cref="P:Microsoft.Diagnostics.Runtime.ClrArray.Address"/> in this instance; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrArray.GetHashCode">
            <summary>
            Returns the hash code for this <see cref="T:Microsoft.Diagnostics.Runtime.ClrArray"/>.
            </summary>
            <returns>An <see cref="T:System.Int32"/> hash code for this instance.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrDelegate">
            <summary>
            Represents a delegate instance in the target process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrDelegate.#ctor(Microsoft.Diagnostics.Runtime.ClrObject)">
            <summary>
            Constructs a <see cref="T:Microsoft.Diagnostics.Runtime.ClrDelegate"/> from a <see cref="T:Microsoft.Diagnostics.Runtime.ClrObject"/>.  Note that obj.IsDelegate
            must be true.
            </summary>
            <param name="obj">A delegate object</param>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrDelegate.HasMultipleTargets">
            <summary>
            Returns whether this delegate has multiple targets or not.  If this method returns true then it is expected
            that <see cref="M:Microsoft.Diagnostics.Runtime.ClrDelegate.GetDelegateTarget"/> will return <see langword="null"/> and you should use
            <see cref="M:Microsoft.Diagnostics.Runtime.ClrDelegate.EnumerateDelegateTargets"/> instead.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrDelegate.Object">
            <summary>
            The actual object represented by this ClrDelegate instance.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrDelegate.GetDelegateTarget">
            <summary>
            Returns a the single delegate target of the
            </summary>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException">If this object is not a delegate we throw</exception>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrDelegate.EnumerateDelegateTargets">
            <summary>
            Enumerates all delegate targets of this delegate.  If called on a MulitcastDelegate, this will enumerate all
            targets that will be called when this delegate is invoked.  If called on a non-MulticastDelegate, this will
            enumerate the value of GetDelegateTarget.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrDelegateTarget">
            <summary>
            The "target" method and object that a delegate points to.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrDelegateTarget.#ctor(Microsoft.Diagnostics.Runtime.ClrDelegate,Microsoft.Diagnostics.Runtime.ClrObject,Microsoft.Diagnostics.Runtime.ClrMethod)">
            <summary>
            Constructor.
            </summary>
            <param name="del">The parent delgate that this target came from.</param>
            <param name="target">The "target" of this delegate.</param>
            <param name="method">The method this delegate will call.</param>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrDelegateTarget.Parent">
            <summary>
            The parent delegate that this target comes from.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrDelegateTarget.TargetObject">
            <summary>
            The object that this delegate is targeted to.  If <see cref="P:Microsoft.Diagnostics.Runtime.ClrDelegateTarget.Method"/> is an instance method,
            this will point to the <see langword="this"/> pointer of that object.  If <see cref="P:Microsoft.Diagnostics.Runtime.ClrDelegateTarget.Method"/>
            is a static method, this will be a pointer to a delegate.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrDelegateTarget.Method">
            <summary>
            The method that would be called when <see cref="P:Microsoft.Diagnostics.Runtime.ClrDelegateTarget.Parent"/> is invoked in the target process.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrDiagnosticsException">
            <summary>
            Exception thrown by Microsoft.Diagnostics.Runtime unless there is a more appropriate
            exception subclass.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrDiagnosticsException.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrDiagnosticsException.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrDiagnosticsException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrDiagnosticsException.#ctor(System.String,System.Int32)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrElementType">
            <summary>
            This is a representation of the metadata element type.  These values
            directly correspond with CLR's CorElementType.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Unknown">
            <summary>
            Not one of the other types.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Void">
            <summary>
            Void type.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Boolean">
            <summary>
            ELEMENT_TYPE_BOOLEAN
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Char">
            <summary>
            ELEMENT_TYPE_CHAR
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Int8">
            <summary>
            ELEMENT_TYPE_I1
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.UInt8">
            <summary>
            ELEMENT_TYPE_U1
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Int16">
            <summary>
            ELEMENT_TYPE_I2
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.UInt16">
            <summary>
            ELEMENT_TYPE_U2
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Int32">
            <summary>
            ELEMENT_TYPE_I4
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.UInt32">
            <summary>
            ELEMENT_TYPE_U4
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Int64">
            <summary>
            ELEMENT_TYPE_I8
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.UInt64">
            <summary>
            ELEMENT_TYPE_U8
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Float">
            <summary>
            ELEMENT_TYPE_R4
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Double">
            <summary>
            ELEMENT_TYPE_R8
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.String">
            <summary>
            ELEMENT_TYPE_STRING
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Pointer">
            <summary>
            ELEMENT_TYPE_PTR
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.ByRef">
            <summary>
            ELEMENT_TYPE_BYREF
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Struct">
            <summary>
            ELEMENT_TYPE_VALUETYPE
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Class">
            <summary>
            ELEMENT_TYPE_CLASS
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Var">
            <summary>
            ELEMENT_TYPE_VAR
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Array">
            <summary>
            ELEMENT_TYPE_ARRAY
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.GenericInstantiation">
            <summary>
            ELEMENT_TYPE_GENERICINST
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.NativeInt">
            <summary>
            ELEMENT_TYPE_I
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.NativeUInt">
            <summary>
            ELEMENT_TYPE_U
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.FunctionPointer">
            <summary>
            ELEMENT_TYPE_FNPTR
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Object">
            <summary>
            ELEMENT_TYPE_OBJECT
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.MVar">
            <summary>
            ELEMENT_TYPE_MVAR
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.SZArray">
            <summary>
            ELEMENT_TYPE_SZARRAY
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrException">
            <summary>
            A wrapper for exception objects which help with common tasks for exception objects.
            Create this using <see cref="M:Microsoft.Diagnostics.Runtime.ClrObject.AsException"/>. You may call that when <see cref="P:Microsoft.Diagnostics.Runtime.ClrObject.IsException"/>
            is <see langword="true"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrException.Thread">
            <summary>
            Gets the original thread this exception was thrown from.  This may be <see langword="null"/> if we do not know.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrException.AsObject">
            <summary>
            Returns this exception's ClrObject representation.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrException.Address">
            <summary>
            Gets the address of the exception object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrException.Type">
            <summary>
            Gets the <see cref="T:Microsoft.Diagnostics.Runtime.ClrType"/> for this exception object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrException.Message">
            <summary>
            Gets the exception message.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrException.Inner">
            <summary>
            Gets the inner exception, if one exists, <see langword="null"/> otherwise.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrException.HResult">
            <summary>
            Gets the HRESULT associated with this exception (or S_OK if there isn't one).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrException.StackTrace">
            <summary>
            Gets the StackTrace for this exception.  Note that this may be empty or partial depending
            on the state of the exception in the process.  (It may have never been thrown or we may be in
            the middle of constructing the stackwalk.)  This returns an empty list if no stack trace is
            associated with this exception object.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrField">
            <summary>
            A representation of a field in the target process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.ContainingType">
            <summary>
            Gets the <see cref="T:Microsoft.Diagnostics.Runtime.ClrType"/> containing this field.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.Name">
            <summary>
            Gets the name of the field.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.Token">
            <summary>
            Gets the type token of this field.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.Type">
            <summary>
            Gets the type of the field.  Note this property may return <see langword="null"/> on error.  There is a bug in several versions
            of our debugging layer which causes this.  You should always null-check the return value of this field.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.ElementType">
            <summary>
            Gets the element type of this field.  Note that even when Type is <see langword="null"/>, this should still tell you
            the element type of the field.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.IsPrimitive">
            <summary>
            Gets a value indicating whether this field is a primitive (<see cref="T:System.Int32"/>, <see cref="T:System.Single"/>, etc).
            </summary>
            <returns>True if this field is a primitive (<see cref="T:System.Int32"/>, <see cref="T:System.Single"/>, etc), false otherwise.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.IsValueType">
            <summary>
            Gets a value indicating whether this field is a value type.
            </summary>
            <returns>True if this field is a value type, false otherwise.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.IsObjectReference">
            <summary>
            Gets a value indicating whether this field is an object reference.
            </summary>
            <returns>True if this field is an object reference, false otherwise.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.Size">
            <summary>
            Gets the size of this field.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.Attributes">
            <summary>
            Attributes of this field;
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.Offset">
            <summary>
            For instance fields, this is the offset of the field within the object.
            For static fields this is the offset within the block of memory allocated for the module's static fields.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrField.ToString">
            <summary>
            Returns a string representation of this object.
            </summary>
            <returns>A string representation of this object.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrFlavor">
            <summary>
            Returns the "flavor" of CLR this module represents.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrFlavor.Desktop">
            <summary>
            This is the full version of CLR included with windows.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrFlavor.Core">
            <summary>
            For .NET Core
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrFlavor.NativeAOT">
            <summary>
            NativeAOT.
            This is not supported by ClrMD, but reserve the enum value here.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrGenericParameter">
            <summary>
            Returns information about generic parameters.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrGenericParameter.MetadataToken">
            <summary>
            The metadata token of the parameter.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrGenericParameter.Index">
            <summary>
            The index of the parameter.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrGenericParameter.Attributes">
            <summary>
            The attributes of the parameter.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrGenericParameter.Name">
            <summary>
            The name of the parameter.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrGenericParameter.#ctor(System.Int32,System.Int32,System.Reflection.GenericParameterAttributes,System.String)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrHandle">
            <summary>
            Represents a CLR handle in the target process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.HandleKind">
            <summary>
            Gets the type of handle.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.ReferenceCount">
            <summary>
            If this handle is a RefCount handle, this returns the reference count.
            RefCount handles with a RefCount > 0 are strong.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.Dependent">
            <summary>
            Gets the dependent handle target if this is a dependent handle.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.AppDomain">
            <summary>
            Gets the AppDomain the handle resides in.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.IsStrong">
            <summary>
            Gets a value indicating whether the handle is strong (roots the object).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHandle.ToString">
            <summary>
            ToString override.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrHandleKind">
            <summary>
            Types of CLR handles.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrHandleKind.WeakShort">
            <summary>
            Weak, short lived handle.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrHandleKind.WeakLong">
            <summary>
            Weak, long lived handle.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrHandleKind.Strong">
            <summary>
            Strong handle.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrHandleKind.Pinned">
            <summary>
            Strong handle, prevents relocation of target object.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrHandleKind.RefCounted">
            <summary>
            RefCounted handle (strong when the reference count is greater than 0).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrHandleKind.Dependent">
            <summary>
            A weak handle which may keep its "secondary" object alive if the "target" object is also alive.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrHandleKind.AsyncPinned">
            <summary>
            A strong, pinned handle (keeps the target object from being relocated), used for async IO operations.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrHandleKind.SizedRef">
            <summary>
            Strong handle used internally for book keeping.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrHandleKind.WeakWinRT">
            <summary>
            Weak WinRT handle.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrHeap">
            <summary>
            A representation of the CLR heap.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHeap.ErrorType">
            <summary>
            An internal only instance of ClrType used to mark that we could not create a valid type...
            but we still need to access the properties off of ClrType, such IClrTypeHelpers, IDataReader, etc.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHeap.Runtime">
            <summary>
            Gets the runtime associated with this heap.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHeap.CanWalkHeap">
            <summary>
            Returns true if the GC heap is in a consistent state for heap enumeration.  This will return false
            if the process was stopped in the middle of a GC, which can cause the GC heap to be unwalkable.
            Note, you may still attempt to walk the heap if this function returns false, but you will likely
            only be able to partially walk each segment.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHeap.SubHeaps">
            <summary>
            Returns the number of logical heaps in the process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHeap.Segments">
            <summary>
            A heap is has a list of contiguous memory regions called segments.  This list is returned in order of
            of increasing object addresses.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHeap.FreeType">
            <summary>
            Gets the <see cref="T:Microsoft.Diagnostics.Runtime.ClrType"/> representing free space on the GC heap.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHeap.StringType">
            <summary>
            Gets the <see cref="T:Microsoft.Diagnostics.Runtime.ClrType"/> representing <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHeap.ObjectType">
            <summary>
            Gets the <see cref="T:Microsoft.Diagnostics.Runtime.ClrType"/> representing <see cref="T:System.Object"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHeap.ExceptionType">
            <summary>
            Gets the <see cref="T:Microsoft.Diagnostics.Runtime.ClrType"/> representing <see cref="T:System.Exception"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHeap.IsServer">
            <summary>
            Gets a value indicating whether the GC heap is in Server mode.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetObject(System.UInt64)">
            <summary>
            Gets a <see cref="T:Microsoft.Diagnostics.Runtime.ClrObject"/> for the given address on this heap.
            </summary>
            <remarks>
            The returned object will have a <see langword="null"/> <see cref="P:Microsoft.Diagnostics.Runtime.ClrObject.Type"/> if objRef does not point to
            a valid managed object.
            </remarks>
            <param name="objRef">The address of an object.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetObject(System.UInt64,Microsoft.Diagnostics.Runtime.ClrType)">
            <summary>
            Gets a <see cref="T:Microsoft.Diagnostics.Runtime.ClrObject"/> for the given address on this heap.
            </summary>
            <remarks>
            The returned object will have a <see langword="null"/> <see cref="P:Microsoft.Diagnostics.Runtime.ClrObject.Type"/> if objRef does not point to
            a valid managed object.
            </remarks>
            <param name="objRef">The address of an object.</param>
            <param name="type">The type of the object.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetObjectType(System.UInt64)">
            <summary>
            Obtains the type of an object at the given address.  Returns <see langword="null"/> if objRef does not point to
            a valid managed object.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateObjects">
            <summary>
            Enumerates all objects on the heap.
            </summary>
            <returns>An enumerator for all objects on the heap.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateObjects(System.Boolean)">
            <summary>
            Enumerates all objects on the heap.
            </summary>
            <param name="carefully">Whether to continue walking objects on a segment where we've encountered
            a region of unwalkable memory.  Note that setting carefully = true may significantly increase the
            amount of time it takes to walk the heap if we encounter an error.</param>
            <returns>An enumerator for all objects on the heap.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateObjects(Microsoft.Diagnostics.Runtime.MemoryRange,System.Boolean)">
            <summary>
            Enumerates objects within the given memory range.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.IsObjectCorrupted(System.UInt64,Microsoft.Diagnostics.Runtime.ObjectCorruption@)">
            <summary>
            Deeply verifies an object on the heap.  This goes beyond just ClrObject.IsValid and will
            check the object's references as well as certain internal CLR data structures.  Please note,
            however, that it is possible to pause a process in a debugger at a point where the heap is
            NOT corrupted, but does look inconsistent to ClrMD.  For example, the GC might allocate
            an array by writing a method table but the process might be paused before it had the chance
            to write the array length onto the heap.  In this case, IsObjectCorrupted may return true
            even if the process would have continued on fine.  As a result, this function acts more
            like a warning signal that more investigation is needed, and not proof-positive that there
            is heap corruption.
            </summary>
            <param name="objAddr">The address of the object to deeply verify.</param>
            <param name="result">Only non-null if this function returns true.  An object which describes the
            kind of corruption found.</param>
            <returns>True if the object is corrupted in some way, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.FullyVerifyObject(System.UInt64,System.Collections.Generic.IEnumerable{Microsoft.Diagnostics.Runtime.ObjectCorruption}@)">
            <summary>
            Deeply verifies an object on the heap.  This goes beyond just ClrObject.IsValid and will
            check the object's references as well as certain internal CLR data structures.  Please note,
            however, that it is possible to pause a process in a debugger at a point where the heap is
            NOT corrupted, but does look inconsistent to ClrMD.  For example, the GC might allocate
            an array by writing a method table but the process might be paused before it had the chance
            to write the array length onto the heap.  In this case, IsObjectCorrupted may return true
            even if the process would have continued on fine.  As a result, this function acts more
            like a warning signal that more investigation is needed, and not proof-positive that there
            is heap corruption.
            </summary>
            <param name="objAddr">The address of the object to deeply verify.</param>
            <param name="detectedCorruption">An enumeration of all issues detected with this object.</param>
            <returns>True if the object is valid and fully verified, returns false if object corruption
            was detected.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.VerifyHeap">
            <summary>
            Verifies the GC Heap and returns an enumerator for any corrupted objects it finds.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.VerifyHeap(System.Collections.Generic.IEnumerable{Microsoft.Diagnostics.Runtime.ClrObject})">
            <summary>
            Verifies the given objects and returns an enumerator for any corrupted objects it finds.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.FindNextObjectOnSegment(System.UInt64,System.Boolean)">
            <summary>
            Finds the next ClrObject on the given segment.
            </summary>
            <param name="address">An address on any ClrSegment.</param>
            <param name="carefully">Whether to continue walking objects on a segment where we've encountered
            a region of unwalkable memory.  Note that setting carefully = true may significantly increase the
            amount of time it takes to walk the heap if we encounter an error.</param>
            <returns>An invalid ClrObject if address doesn't lie on any segment or if no objects exist after the given address on a segment.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.FindPreviousObjectOnSegment(System.UInt64,System.Boolean)">
            <summary>
            Finds the previous object on the given segment.
            </summary>
            <param name="address">An address on any ClrSegment.</param>
            <param name="carefully">Whether to continue walking objects on a segment where we've encountered
            a region of unwalkable memory.  Note that setting carefully = true may significantly increase the
            amount of time it takes to walk the heap if we encounter an error.</param>
            <returns>An enumerator for all objects on the heap.</returns>
            <returns>An invalid ClrObject if address doesn't lie on any segment or if address is the first object on a segment.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateRoots">
            <summary>
            Enumerates all roots in the process.  Equivalent to the combination of:
                ClrRuntime.EnumerateHandles().Where(handle => handle.IsStrong)
                ClrRuntime.EnumerateThreads().SelectMany(thread => thread.EnumerateStackRoots())
                ClrHeap.EnumerateFinalizerRoots()
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetSegmentByAddress(System.UInt64)">
            <summary>
            Returns the GC segment which contains the given address.  This only searches ClrSegment.ObjectRange.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateFinalizableObjects">
            <summary>
            Enumerates all finalizable objects on the heap.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateFinalizerRoots">
            <summary>
            Enumerates all finalizable objects on the heap.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateAllocationContexts">
            <summary>
            Enumerates all AllocationContexts for all segments.  Allocation contexts are locations on the GC
            heap which the GC uses to allocate new objects.  These regions of memory do not contain objects.
            AllocationContexts are the reason that you cannot simply enumerate the heap by adding each object's
            size to itself to get the next object on the segment, since if the address is an allocation context
            you will have to skip past it to find the next valid object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.ToString">
            <summary>
            Returns a string representation of this heap, including the size and number of segments.
            </summary>
            <returns>The string representation of this heap.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetComFlags(System.UInt64)">
            <summary>
            This is an implementation helper.  Use ClrObject.IsComCallWrapper and ClrObject.IsRuntimeCallWrapper instead.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetObjectSize(System.UInt64,Microsoft.Diagnostics.Runtime.ClrType)">
            <summary>
            This is an implementation helper.  Use ClrObject.Size instead.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateObjectReferences(System.UInt64,Microsoft.Diagnostics.Runtime.ClrType,System.Boolean,System.Boolean)">
            <summary>
            This is an implementation helper.  Use <see cref="M:Microsoft.Diagnostics.Runtime.ClrObject.EnumerateReferences(System.Boolean,System.Boolean)">ClrObject.EnumerateReferences</see> instead.
            Enumerates all objects that the given object references.  This method is meant for internal use to
            implement ClrObject.EnumerateReferences, which you should use instead of calling this directly.
            </summary>
            <param name="obj">The object in question.</param>
            <param name="type">The type of the object.</param>
            <param name="considerDependantHandles">Whether to consider dependant handle mappings.</param>
            <param name="carefully">
            Whether to bounds check along the way (useful in cases where
            the heap may be in an inconsistent state.)
            </param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateReferencesWithFields(System.UInt64,Microsoft.Diagnostics.Runtime.ClrType,System.Boolean,System.Boolean)">
            <summary>
            This is an implementation helper.
            Enumerates all objects that the given object references.  This method is meant for internal use to
            implement ClrObject.EnumerateReferencesWithFields, which you should use instead of calling this directly.
            </summary>
            <param name="obj">The object in question.</param>
            <param name="type">The type of the object.</param>
            <param name="considerDependantHandles">Whether to consider dependant handle mappings.</param>
            <param name="carefully">
            Whether to bounds check along the way (useful in cases where
            the heap may be in an inconsistent state.)
            </param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateReferenceAddresses(System.UInt64,Microsoft.Diagnostics.Runtime.ClrType,System.Boolean,System.Boolean)">
            <summary>
            This is an implementation helper.
            Enumerates all objects that the given object references.  This method is meant for internal use to
            implement ClrObject.EnumerateReferenceAddresses which you should use instead of calling this directly.
            </summary>
            <param name="obj">The object in question.</param>
            <param name="type">The type of the object.</param>
            <param name="considerDependantHandles">Whether to consider dependant handle mappings.</param>
            <param name="carefully">
            Whether to bounds check along the way (useful in cases where
            the heap may be in an inconsistent state.)
            </param>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrInfo">
            <summary>
            Represents information about a single CLR in a process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrInfo.DataTarget">
            <summary>
            The DataTarget containing this ClrInfo.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrInfo.ClrInfoProvider">
            <summary>
            The IClrInfoProvider which created this ClrInfo.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrInfo.Version">
            <summary>
            Gets the version number of this runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrInfo.IsSingleFile">
            <summary>
            Returns whether this CLR was built as a single file executable.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrInfo.Flavor">
            <summary>
            Gets the type of CLR this module represents.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrInfo.DebuggingLibraries">
            <summary>
            A list of debugging libraries associated associated with this .Net runtime.
            This can contain both the dac (used by ClrMD) and the DBI (not used by ClrMD).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrInfo.ModuleInfo">
            <summary>
            Gets module information about the ClrInstance.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrInfo.IndexTimeStamp">
            <summary>
            The timestamp under which this CLR is is archived (0 if this module is indexed under
            a BuildId instead).  Note that this may be a different value from ModuleInfo.IndexTimeStamp.
            In a single-file scenario, the ModuleInfo will be the info of the program's main executable
            and not CLR's properties.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrInfo.IndexFileSize">
            <summary>
            The filesize under which this CLR is is archived (0 if this module is indexed under
            a BuildId instead).  Note that this may be a different value from ModuleInfo.IndexFileSize.
            In a single-file scenario, the ModuleInfo will be the info of the program's main executable
            and not CLR's properties.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrInfo.BuildId">
            <summary>
            The BuildId under which this CLR is archived.  BuildId.IsEmptyOrDefault will be true if
            this runtime is archived under file/timesize instead.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInfo.ToString">
            <summary>
            To string.
            </summary>
            <returns>A version string for this CLR.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInfo.CreateRuntime(System.String)">
            <summary>
            Creates a runtime from the given DAC file on disk.  This is equivalent to
            CreateRuntime(dacPath, ignoreMismatch: false).
            </summary>
            <param name="dacPath">A full path to the matching DAC dll for this process.</param>
            <returns>The runtime associated with this CLR.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInfo.CreateRuntime(System.String,System.Boolean)">
            <summary>
            Creates a runtime from the given DAC file on disk.
            </summary>
            <param name="dacPath">A full path to the matching DAC dll for this process.</param>
            <param name="ignoreMismatch">Whether or not to ignore mismatches between. </param>
            <returns>The runtime associated with this CLR.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInfo.CreateRuntime">
            <summary>
            Creates a runtime by searching for the correct dac to load.
            </summary>
            <returns>The runtime associated with this CLR.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrInstanceField">
            <summary>
            Represents an instance field of a type.   Fundamentally it represents a name and a type
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInstanceField.Read``1(System.UInt64,System.Boolean)">
            <summary>
            Reads the value of the field as an unmanaged struct or primitive type.
            </summary>
            <typeparam name="T">An unmanaged struct or primitive type.</typeparam>
            <param name="objRef">The object to read the instance field from.</param>
            <param name="interior">Whether or not the field is interior to a struct.</param>
            <returns>The value read.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInstanceField.ReadObject(System.UInt64,System.Boolean)">
            <summary>
            Reads the value of an object field.
            </summary>
            <param name="objRef">The object to read the instance field from.</param>
            <param name="interior">Whether or not the field is interior to a struct.</param>
            <returns>The value read.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInstanceField.ReadStruct(System.UInt64,System.Boolean)">
            <summary>
            Reads a ValueType struct from the instance field.
            </summary>
            <param name="objRef">The object to read the instance field from.</param>
            <param name="interior">Whether or not the field is interior to a struct.</param>
            <returns>The value read.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInstanceField.ReadString(System.UInt64,System.Boolean)">
            <summary>
            Reads a string from the instance field.
            </summary>
            <param name="objRef">The object to read the instance field from.</param>
            <param name="interior">Whether or not the field is interior to a struct.</param>
            <returns>The value read.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInstanceField.GetAddress(System.UInt64)">
            <summary>
            Returns the address of the value of this field.  Equivalent to GetFieldAddress(objRef, false).
            </summary>
            <param name="objRef">The object to get the field address for.</param>
            <returns>The value of the field.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInstanceField.GetAddress(System.UInt64,System.Boolean)">
            <summary>
            Returns the address of the value of this field.  Equivalent to GetFieldAddress(objRef, false).
            </summary>
            <param name="objRef">The object to get the field address for.</param>
            <param name="interior">
            Whether the enclosing type of this field is a value class,
            and that value class is embedded in another object.
            </param>
            <returns>The value of the field.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrInterface">
            <summary>
            An interface implementation in the target process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrInterface.Name">
            <summary>
            Gets the typename of the interface.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrInterface.BaseInterface">
            <summary>
            Gets the interface that this interface inherits from.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInterface.ToString">
            <summary>
            Display string for this interface.
            </summary>
            <returns>Display string for this interface.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInterface.Equals(System.Object)">
            <summary>
            Equals override.
            </summary>
            <param name="obj">Object to compare to.</param>
            <returns>True if this interface equals another.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInterface.GetHashCode">
            <summary>
            GetHashCode override.
            </summary>
            <returns>A hashcode for this object.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrMethod">
            <summary>
            Represents a method on a class.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.MethodDesc">
            <summary>
            Gets the first MethodDesc in EnumerateMethodDescs().  For single
            AppDomain programs this is the only MethodDesc.  MethodDescs
            are unique to an Method/AppDomain pair, so when there are multiple domains
            there will be multiple MethodDescs for a method.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.Name">
            <summary>
            Gets the name of the method.  For example, "void System.Foo.Bar(object o, int i)" would return "Bar".
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.Signature">
            <summary>
            Gets the full signature of the function.  For example, "void System.Foo.Bar(object o, int i)"
            would return "System.Foo.Bar(System.Object, System.Int32)"
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.NativeCode">
            <summary>
            Gets the instruction pointer in the target process for the start of the method's assembly.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrMethod.GetILOffset(System.UInt64)">
            <summary>
            Gets the ILOffset of the given address within this method.
            </summary>
            <param name="addr">The absolute address of the code (not a relative offset).</param>
            <returns>The IL offset of the given address.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrMethod.GetILInfo">
            <summary>
            Gets the location in memory of the IL for this method.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.HotColdInfo">
            <summary>
            Gets the regions of memory that
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.CompilationType">
            <summary>
            Gets the way this method was compiled.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.ILOffsetMap">
            <summary>
            Gets the IL to native offset mapping.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.MetadataToken">
            <summary>
            Gets the metadata token of the current method.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.Type">
            <summary>
            Gets the enclosing type of this method.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsConstructor">
            <summary>
            Gets a value indicating whether this method is an instance constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsClassConstructor">
            <summary>
            Gets a value indicating whether this method is a static constructor.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrModule">
            <summary>
            Represents a managed module in the target process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.Address">
            <summary>
            Gets the address of the clr!Module object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.AppDomain">
            <summary>
            Gets the AppDomain parent of this module.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.AssemblyName">
            <summary>
            Gets the name of the assembly that this module is defined in.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.AssemblyAddress">
            <summary>
            Gets an identifier to uniquely represent this assembly.  This value is not used by any other
            function in ClrMD, but can be used to group modules by their assembly.  (Do not use AssemblyName
            for this, as reflection and other special assemblies can share the same name, but actually be
            different.)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.Name">
            <summary>
            Gets the name of the module.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.IsDynamic">
            <summary>
            Gets a value indicating whether this module was created through <c>System.Reflection.Emit</c> (and thus has no associated
            file).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.IsPEFile">
            <summary>
            Gets a value indicating whether this module is an actual PEFile on disk.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.ImageBase">
            <summary>
            Gets the base of the image loaded into memory.  This may be 0 if there is not a physical
            file backing it.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.Layout">
            <summary>
            Returns the in memory layout for PEImages.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.Size">
            <summary>
            Gets the size of the image in memory.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.MetadataAddress">
            <summary>
            Gets the location of metadata for this module in the process's memory.  This is useful if you
            need to manually create IMetaData* objects.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.MetadataLength">
            <summary>
            Gets the length of the metadata for this module.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.MetadataReader">
            <summary>
            Gets the <c>IMetaDataImport</c> interface for this module.  Note that this API does not provide a
            wrapper for <c>IMetaDataImport</c>.  You will need to wrap the API yourself if you need to use this.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.ThunkHeap">
            <summary>
            The ThunkHeap associated with this Module.  This is only available when debugging a .Net 8 or
            later runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.LoaderAllocator">
            <summary>
            The LoaderAllocator associated with this Module.  This is only available when debugging a .Net 8 or
            later runtime.  Note that this LoaderAllocator is usually share with its parent domain, except in
            rare circumstances, like for collectable assemblies.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrModule.EnumerateThunkHeap">
            <summary>
            Enumerates the native heaps associated with the ThunkHeap.
            </summary>
            <returns>An enumerable of heaps.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrModule.EnumerateLoaderAllocatorHeaps">
            <summary>
            Enumerates the native heaps associated with the LoaderAllocator.  This may be the same set of
            heaps enumerated by ClrAppDomain.EnumerateLoaderAllocatorHeaps if LoaderAllocator is not 0 and
            equals ClrAppDomain.LoaderAllocator.
            </summary>
            <returns>An enumerable of heaps.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.DebuggingMode">
            <summary>
            Gets the debugging attributes for this module.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrModule.EnumerateTypeDefToMethodTableMap">
            <summary>
            Enumerates the constructed methodtables in this module which correspond to typedef tokens defined by this module.
            </summary>
            <returns>An enumeration of (ulong methodTable, uint typeDef).</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrModule.GetTypeByName(System.String)">
            <summary>
            Attempts to obtain a ClrType based on the name of the type.  Note this is a "best effort" due to
            the way that the DAC handles types.  This function will fail for Generics, and types which have
            never been constructed in the target process.  Please be sure to null-check the return value of
            this function.
            </summary>
            <param name="name">The name of the type.  (This would be the EXACT value returned by ClrType.Name.)</param>
            <returns>The requested ClrType, or <see langword="null"/> if the type doesn't exist or if the runtime hasn't constructed it.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrModule.ToString">
            <summary>
            Returns a name for the assembly.
            </summary>
            <returns>A name for the assembly.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.Pdb">
            <summary>
            Gets the PDB information for this module.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrNativeHeapInfo">
            <summary>
            A region of native memory allocated by CLR.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrNativeHeapInfo.MemoryRange">
            <summary>
            The range of memory of this heap.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrNativeHeapInfo.Kind">
            <summary>
            The kind of heap this is.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrNativeHeapInfo.State">
            <summary>
            The additional state info of this memory, if applicable.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrNativeHeapInfo.GCHeap">
            <summary>
            The ClrSubHeap index associated with this native heap or -1 if none.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrNativeHeapInfo.#ctor(Microsoft.Diagnostics.Runtime.MemoryRange,Microsoft.Diagnostics.Runtime.NativeHeapKind,Microsoft.Diagnostics.Runtime.ClrNativeHeapState)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrNativeHeapInfo.#ctor(Microsoft.Diagnostics.Runtime.MemoryRange,Microsoft.Diagnostics.Runtime.NativeHeapKind,Microsoft.Diagnostics.Runtime.ClrNativeHeapState,System.Int32)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrNativeHeapInfo.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrNativeHeapState">
            <summary>
            Additional info about CLR native heaps.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrNativeHeapState.None">
            <summary>
            No additional info.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrNativeHeapState.Active">
            <summary>
            Committed memory.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrNativeHeapState.Inactive">
            <summary>
            Memory which is no longer the active block in a heap.
            For example, some CLR allocators incrementally commit new blocks of memory after it
            has filled the current block of memory, then never go back and attempt to add more
            data to those previous blocks.  The previous blocks are "inactive".
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrNativeHeapState.RegionOfRegions">
            <summary>
            This region of memory contains the bounds of memory where the heap or allocator will
            exclusively allocate memory within.  All memory within this memory range is a part of
            this native heap.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrObject">
            <summary>
            Represents an object in the target process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.#ctor(System.UInt64,Microsoft.Diagnostics.Runtime.ClrType)">
            <summary>
            Constructor.
            </summary>
            <param name="address">The address of the object.</param>
            <param name="type">The concrete type of the object.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.EnumerateReferences(System.Boolean,System.Boolean)">
            <summary>
            Enumerates all objects that this object references.
            </summary>
            <param name="carefully">Only returns pointers which lie on the managed heap.  In very rare cases it's possible to
            create a crash dump where the GC was in the middle of updating data structures, or to create a crash dump of a process
            with heap corruption.  In those cases, setting carefully=true would ensure we would not enumerate those bad references.
            Note that setting carefully=true will cause a small performance penalty.</param>
            <param name="considerDependantHandles">Setting this to true will have ClrMD check for dependent handle references.
            Checking dependent handles does come at a performance penalty but will give you the true reference chain as the
            GC sees it.</param>
            <returns>An enumeration of object references.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.EnumerateReferencesWithFields(System.Boolean,System.Boolean)">
            <summary>
            Enumerates all objects that this object references.  This method also enumerates the field (or handle) that this
            reference comes from.
            </summary>
            <param name="carefully">Only returns pointers which lie on the managed heap.  In very rare cases it's possible to
            create a crash dump where the GC was in the middle of updating data structures, or to create a crash dump of a process
            with heap corruption.  In those cases, setting carefully=true would ensure we would not enumerate those bad references.
            Note that setting carefully=true will cause a small performance penalty.</param>
            <param name="considerDependantHandles">Setting this to true will have ClrMD check for dependent handle references.
            Checking dependent handles does come at a performance penalty but will give you the true reference chain as the
            GC sees it.</param>
            <returns>An enumeration of object references.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.EnumerateReferenceAddresses(System.Boolean,System.Boolean)">
            <summary>
            Enumerates all objects that this object references.
            </summary>
            <param name="carefully">Only returns pointers which lie on the managed heap.  In very rare cases it's possible to
            create a crash dump where the GC was in the middle of updating data structures, or to create a crash dump of a process
            with heap corruption.  In those cases, setting carefully=true would ensure we would not enumerate those bad references.
            Note that setting carefully=true will cause a small performance penalty.</param>
            <param name="considerDependantHandles">Setting this to true will have ClrMD check for dependent handle references.
            Checking dependent handles does come at a performance penalty but will give you the true reference chain as the
            GC sees it.</param>
            <returns>An enumeration of object references.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrObject.IsBoxedValue">
            <summary>
            Returns true if this object is a boxed struct or primitive type that
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.ReadBoxedValue``1">
            <summary>
            Reads a boxed primitive value.
            </summary>
            <typeparam name="T">An unmanaged struct or primitive type to read out of the object.</typeparam>
            <returns>The value read.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrObject.Address">
            <summary>
            Gets the address of the object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrObject.Type">
            <summary>
            Gets the type of the object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrObject.IsFree">
            <summary>
            Returns whether this is free space on the GC heap and not a real object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrObject.IsValid">
            <summary>
            Returns whether this is a valid object.  This will return null
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrObject.IsNull">
            <summary>
            Returns if the object value is <see langword="null"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrObject.Size">
            <summary>
            Gets the size of the object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrObject.SyncBlock">
            <summary>
            Obtains the SyncBlock for this object.  Returns null if there is no SyncBlock associated with this object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrObject.IsComClassFactory">
            <summary>
            Returns true if this object is a COM class factory.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrObject.HasComCallableWrapper">
            <summary>
            Returns true if this object is a ComCallableWrapper.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrObject.HasRuntimeCallableWrapper">
            <summary>
            Returns true if this object is a RuntimeCallableWrapper.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.GetComCallableWrapper">
            <summary>
            Returns the ComCallableWrapper for the given object.
            </summary>
            <returns>The ComCallableWrapper associated with the object, <see langword="null"/> if obj is not a CCW.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.GetRuntimeCallableWrapper">
            <summary>
            Returns the RuntimeCallableWrapper for the given object.
            </summary>
            <returns>The RuntimeCallableWrapper associated with the object, <see langword="null"/> if obj is not a RCW.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrObject.ContainsPointers">
            <summary>
            Gets a value indicating whether this object possibly contains GC pointers.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrObject.IsArray">
            <summary>
            Gets a value indicating whether this object is an array.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.AsArray">
            <summary>
            returns the object as an array if the object has array type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.op_Explicit(Microsoft.Diagnostics.Runtime.ClrObject)~System.String">
            <summary>
            Converts a ClrObject into its string value.
            </summary>
            <param name="obj">A string object.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.op_Implicit(Microsoft.Diagnostics.Runtime.ClrObject)~System.UInt64">
            <summary>
            Returns <see cref="P:Microsoft.Diagnostics.Runtime.ClrObject.Address"/> sweetening obj to pointer move.
            <Para>Example: ulong address = clrObject</Para>
            </summary>
            <param name="clrObject">An object to get address of.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.TryReadObjectField(System.String,Microsoft.Diagnostics.Runtime.ClrObject@)">
            <summary>
            Tries to obtain the given object field from this ClrObject.  Returns false if the field wasn't found or if
            the underlying type was not an object.
            </summary>
            <param name="fieldName">The name of the field to retrieve.</param>
            <param name="result">True if the field was found and the field's type is an object.  Returns false otherwise.</param>
            <returns>A ClrObject of the given field.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.TryReadStringField(System.String,System.Nullable{System.Int32},System.String@)">
            <summary>
            Tries to obtain the given string field from this ClrObject.  Returns false if the field wasn't found or if
            the underlying type was not a string..
            </summary>
            <param name="fieldName">The name of the field to retrieve.</param>
            <param name="maxLength">The string max length or the default.</param>
            <param name="result">True if the field was found and the field's type is a string.  Returns false otherwise.</param>
            <returns>A string of the given field.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.ReadObjectField(System.String)">
            <summary>
            Gets the given object reference field from this ClrObject.
            </summary>
            <param name="fieldName">The name of the field to retrieve.</param>
            <returns>A ClrObject of the given field.</returns>
            <exception cref="T:System.ArgumentException">The given field does not exist in the object.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:Microsoft.Diagnostics.Runtime.ClrObject.IsNull"/> is <see langword="true"/>.</exception>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.ReadField``1(System.String)">
            <summary>
            Gets the value of a primitive field.
            </summary>
            <typeparam name="T">The type of the field itself.</typeparam>
            <param name="fieldName">The name of the field.</param>
            <returns>The value of this field.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.TryReadField``1(System.String,``0@)">
            <summary>
            Attempts to read the value of a primitive field.  This method does no type checking on whether T
            matches the field's type.
            </summary>
            <typeparam name="T">The type of the field itself.</typeparam>
            <param name="fieldName">The name of the field.</param>
            <param name="result">The value of the missing field.</param>
            <returns>True if we obtained this field and read its value, false otherwise.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrObject.IsDelegate">
            <summary>
            Returns true if this object is a delegate, false otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.AsDelegate">
            <summary>
            Returns this object in a <see cref="T:Microsoft.Diagnostics.Runtime.ClrDelegate"/> view.  Note it is only valid to call
            <see cref="M:Microsoft.Diagnostics.Runtime.ClrObject.AsDelegate"/> if the underlying object is a subclass of System.Delegate.  You
            can check <see cref="P:Microsoft.Diagnostics.Runtime.ClrObject.IsDelegate"/> before calling <see cref="M:Microsoft.Diagnostics.Runtime.ClrObject.AsDelegate"/>, but that is
            not required as long as you are sure the object is a delegate or should be treated like
            one.
            </summary>
            <returns>Returns this object in a <see cref="T:Microsoft.Diagnostics.Runtime.ClrDelegate"/> view.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.ReadStringField(System.String,System.Int32)">
            <summary>
            Gets a string field from the object.  Note that the type must match exactly, as this method
            will not do type coercion.
            </summary>
            <param name="fieldName">The name of the field to get the value for.</param>
            <param name="maxLength">The maximum length of the string returned.  Warning: If the DataTarget
            being inspected has corrupted or an inconsistent heap state, the length of a string may be
            incorrect, leading to OutOfMemory and other failures.</param>
            <returns>The value of the given field.</returns>
            <exception cref="T:System.ArgumentException">No field matches the given name.</exception>
            <exception cref="T:System.InvalidOperationException">
            The target object is <see langword="null"/> (that is, <see cref="P:Microsoft.Diagnostics.Runtime.ClrObject.IsNull"/> is <see langword="true"/>).
            -or-
            The field is not of the correct type.
            </exception>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.Equals(Microsoft.Diagnostics.Runtime.ClrObject)">
            <summary>
            Determines if this instance and another specific <see cref="T:Microsoft.Diagnostics.Runtime.ClrObject" /> have the same value.
            <para>Instances are considered equal when they have same <see cref="P:Microsoft.Diagnostics.Runtime.ClrObject.Address" />.</para>
            </summary>
            <param name="other">The <see cref="T:Microsoft.Diagnostics.Runtime.ClrObject" /> to compare to this instance.</param>
            <returns><see langword="true"/> if the <see cref="P:Microsoft.Diagnostics.Runtime.ClrObject.Address" /> of the parameter is same as <see cref="P:Microsoft.Diagnostics.Runtime.ClrObject.Address" /> in this instance; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.GetHashCode">
            <summary>
            Returns the hash code for this <see cref="T:Microsoft.Diagnostics.Runtime.ClrObject" /> based on its <see cref="P:Microsoft.Diagnostics.Runtime.ClrObject.Address" />.
            </summary>
            <returns>An <see cref="T:System.Int32" /> hash code for this instance.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.op_Equality(Microsoft.Diagnostics.Runtime.ClrObject,Microsoft.Diagnostics.Runtime.ClrObject)">
            <summary>
            Determines whether two specified <see cref="T:Microsoft.Diagnostics.Runtime.ClrObject" /> have the same value.
            </summary>
            <param name="left">First <see cref="T:Microsoft.Diagnostics.Runtime.ClrObject" /> to compare.</param>
            <param name="right">Second <see cref="T:Microsoft.Diagnostics.Runtime.ClrObject" /> to compare.</param>
            <returns><see langword="true"/> if <paramref name="left" /> <see cref="M:Microsoft.Diagnostics.Runtime.ClrObject.Equals(Microsoft.Diagnostics.Runtime.ClrObject)" /> <paramref name="right" />; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.op_Inequality(Microsoft.Diagnostics.Runtime.ClrObject,Microsoft.Diagnostics.Runtime.ClrObject)">
            <summary>
            Determines whether two specified <see cref="T:Microsoft.Diagnostics.Runtime.ClrObject" /> have different values.
            </summary>
            <param name="left">First <see cref="T:Microsoft.Diagnostics.Runtime.ClrObject" /> to compare.</param>
            <param name="right">Second <see cref="T:Microsoft.Diagnostics.Runtime.ClrObject" /> to compare.</param>
            <returns><see langword="true"/> if the value of <paramref name="left" /> is different from the value of <paramref name="right" />; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.ToString">
            <summary>
            ToString override.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrReference.Object">
            <summary>
            The object that <see cref="P:Microsoft.Diagnostics.Runtime.ClrReference.Field"/> contained.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrReference.Offset">
            <summary>
            The offset into the containing object this address is found at.  Only valid if <see cref="P:Microsoft.Diagnostics.Runtime.ClrReference.IsField"/> is true.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrReference.InnerField">
            <summary>
            Resolves the inner field reference for value types.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrReference.Field">
            <summary>
            The field this object was contained in.  This property may be null if this reference came from
            a DependentHandle or if the reference came from an array entry.
            Only valid to call if <see cref="P:Microsoft.Diagnostics.Runtime.ClrReference.IsField"/> is true.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrReference.IsDependentHandle">
            <summary>
            Returns true if this reference came from a dependent handle.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrReference.IsField">
            <summary>
            Returns true if this reference came from a field in another object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrReference.IsArrayElement">
            <summary>
            Returns true if this reference came from an entry in an array.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrReference.CreateFromDependentHandle(Microsoft.Diagnostics.Runtime.ClrObject)">
            <summary>
            Create a field reference from a dependent handle value.  We do not keep track of the dependent handle it came from
            so we don't accept the value here.
            </summary>
            <param name="reference">The object referenced.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrReference.CreateFromFieldOrArray(Microsoft.Diagnostics.Runtime.ClrObject,Microsoft.Diagnostics.Runtime.ClrType,System.Int32)">
            <summary>
            Creates a ClrFieldReference from an actual field.
            </summary>
            <param name="reference">The object referenced.</param>
            <param name="containingType">The type of the object which points to <paramref name="reference"/>.</param>
            <param name="offset">The offset within the source object where <paramref name="reference"/> was located.  This offset
            should start from where the object's data starts (IE this offset should NOT contain the MethodTable in the offset
            calculation.</param>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRoot.Address">
            <summary>
            Gets the address in memory of the root.  Typically dereferencing this address will
            give you the associated Object, but not always.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRoot.Object">
            <summary>
            Gets the object the root points to.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRoot.RootKind">
            <summary>
            Gets the kind of root this is.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRoot.IsInterior">
            <summary>
            Gets a value indicating whether Address may point to the interior of an object (i.e. not the start of an object).
            If Address happens to point to the start of the object, ClrRoot.Object will be filled
            as normal, otherwise ClrRoot.Object.IsNull will be <see langword="true"/>.  In order to properly account
            for interior objects, you must read the value out of Address then find the object which
            contains it.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRoot.IsPinned">
            <summary>
            Gets a value indicating whether the object is pinned in place by this root and will not be relocated by the GC.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrRootKind">
            <summary>
            The type of GCRoot that a ClrRoot represents.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrRootKind.None">
            <summary>
            This is not a gc root.  This will not be enumerated out of ClrHeap.EnumerateRoots, but
            could be seen when using ClrRuntime.EnumerateHandles.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrRootKind.FinalizerQueue">
            <summary>
            The root comes from the finalizer queue.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrRootKind.StrongHandle">
            <summary>
            The root is a strong handle.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrRootKind.PinnedHandle">
            <summary>
            The root is a strong pinned handle.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrRootKind.Stack">
            <summary>
            The root is on the stack of a thread.  This is usually a is a local variable
            (or compiler generated temporary variable).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrRootKind.RefCountedHandle">
            <summary>
            The root is a ref counted handle.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrRootKind.AsyncPinnedHandle">
            <summary>
            The root is an async IO (strong) pinned handle.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrRootKind.SizedRefHandle">
            <summary>
            The root is a SizedRef handle.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrRuntime">
            <summary>
            Represents a single runtime in a target process or crash dump.  This serves as the primary
            entry point for getting diagnostic information.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.FlushCachedData">
            <summary>
            Flushes the DAC cache.  This function MUST be called any time you expect to call the same function
            but expect different results.  For example, after walking the heap, you need to call Flush before
            attempting to walk the heap again.  After calling this function, you must discard ALL ClrMD objects
            you have cached other than DataTarget and ClrRuntime and re-request the objects and data you need.
            (e.g. if you want to use the ClrHeap object after calling flush, you must call ClrRuntime.GetHeap
            again after Flush to get a new instance.)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.CanFlushData">
            <summary>
            Returns whether this version of CLR diagnostics supports flushing data.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.ClrInfo">
            <summary>
            Gets the <see cref="P:Microsoft.Diagnostics.Runtime.ClrRuntime.ClrInfo"/> of the current runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.DataTarget">
            <summary>
            Gets the <see cref="P:Microsoft.Diagnostics.Runtime.ClrRuntime.DataTarget"/> associated with this runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.IsThreadSafe">
            <summary>
            Returns whether you are allowed to call into the transitive closure of ClrMD objects created from
            this runtime on multiple threads.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.AppDomains">
            <summary>
            Gets the list of appdomains in the process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.SystemDomain">
            <summary>
            Gets the System AppDomain for Desktop CLR (<see langword="null"/> on .NET Core).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.SharedDomain">
            <summary>
            Gets the Shared AppDomain for Desktop CLR (<see langword="null"/> on .NET Core).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.ThreadPool">
            <summary>
            Gets information about CLR's ThreadPool.  May return null if we could not obtain
            ThreadPool data from the target process or dump.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.Threads">
            <summary>
            Gets all managed threads in the process.  Only threads which have previously run managed
            code will be enumerated.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.GetAppDomainByAddress(System.UInt64)">
            <summary>
            Returns a ClrAppDomain by its address.
            </summary>
            <param name="appDomain">The address of an AppDomain.  This is the pointer to CLR's internal runtime
            structure.</param>
            <returns>The ClrAppDomain corresponding to this address, or null if none were found.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.GetMethodByHandle(System.UInt64)">
            <summary>
            Returns a ClrMethod by its internal runtime handle (on desktop CLR this is a MethodDesc).
            </summary>
            <param name="methodHandle">The method handle (MethodDesc) to look up.</param>
            <returns>The ClrMethod for the given method handle, or <see langword="null"/> if no method was found.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.GetTypeByMethodTable(System.UInt64)">
            <summary>
            Gets the <see cref="T:Microsoft.Diagnostics.Runtime.ClrType"/> corresponding to the given MethodTable.
            </summary>
            <param name="methodTable">The ClrType.MethodTable for the requested type.</param>
            <returns>A ClrType object, or <see langword="null"/> if no such type exists.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.EnumerateHandles">
            <summary>
            Enumerates a list of GC handles currently in the process.  Note that this list may be incomplete
            depending on the state of the process when we attempt to walk the handle table.
            </summary>
            <returns>An enumeration of GC handles in the process.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.Heap">
            <summary>
            Gets the GC heap of the process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.GetMethodByInstructionPointer(System.UInt64)">
            <summary>
            Attempts to get a ClrMethod for the given instruction pointer.  This will return NULL if the
            given instruction pointer is not within any managed method.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.EnumerateModules">
            <summary>
            Enumerate all managed modules in the runtime.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.EnumerateClrNativeHeaps">
            <summary>
            Enumerates all native heaps that CLR has allocated.  This method is used to give insights into
            what native memory ranges are owned by CLR.  For example, this is the information enumerated
            by SOS's !eeheap and "!ext maddress".
            </summary>
            <returns>An enumeration of heaps.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.EnumerateJitManagers">
            <summary>
            Enumerates native heaps that the JIT has allocated.
            </summary>
            <returns>An enumeration of heaps.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.GetJitHelperFunctionName(System.UInt64)">
            <summary>
            Gets the name of a JIT helper function.
            </summary>
            <param name="address">Address of a possible JIT helper function.</param>
            <returns>The name of the JIT helper function or <see langword="null"/> if <paramref name="address"/> isn't a JIT helper function.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.Dispose">
            <summary>
            Cleans up all resources and releases them.  You may not use this ClrRuntime or any object it transitively
            created after calling this method.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrSegment">
            <summary>
            A ClrSegment represents a contiguous region of memory that is devoted to the GC heap.
            Segments.  It has a start and end and knows what heap it belongs to.   Segments can
            optional have regions for Gen 0, 1 and 2, and Large properties.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Address">
            <summary>
            The address of the CLR segment object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.ObjectRange">
            <summary>
            The memory range of the segment on which objects are allocated.  All objects in this segment fall within this range.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Start">
            <summary>
            Gets the start address of the segment.  Equivalent to <see cref="P:Microsoft.Diagnostics.Runtime.ClrSegment.ObjectRange"/>.<see cref="P:Microsoft.Diagnostics.Runtime.ClrSegment.Start"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.End">
            <summary>
            Gets the end address of the segment.  Equivalent to <see cref="P:Microsoft.Diagnostics.Runtime.ClrSegment.ObjectRange"/>.<see cref="P:Microsoft.Diagnostics.Runtime.ClrSegment.Length"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Length">
            <summary>
            Equivalent to <see cref="P:Microsoft.Diagnostics.Runtime.ClrSegment.ObjectRange"/>.<see cref="P:Microsoft.Diagnostics.Runtime.ClrSegment.Length"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.SubHeap">
            <summary>
            Gets the SubHeap this segment lives on.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.ReservedMemory">
            <summary>
            Gets the range of memory reserved (but not committed) for this segment.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.CommittedMemory">
            <summary>
            Gets the range of memory committed for the segment (this may be larger than MemoryRange).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.FirstObjectAddress">
            <summary>
            Gets the first object on this segment or 0 if this segment contains no objects.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Kind">
            <summary>
            The kind of segment this is.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.IsPinned">
            <summary>
            Returns true if the objects in this segment are pinned and cannot be relocated.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Generation0">
            <summary>
            The memory range for Generation 0 on this segment.  This will be empty if this is not an ephemeral segment.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Generation1">
            <summary>
            The memory range for Generation 1 on this segment.  This will be empty if this is not an ephemeral segment.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Generation2">
            <summary>
            The memory range for Generation 2 on this segment.  This will be empty if this is not an ephemeral segment.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrSegment.EnumerateObjects(System.Boolean)">
            <summary>
            Enumerates all objects on the segment.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrSegment.EnumerateObjects(Microsoft.Diagnostics.Runtime.MemoryRange,System.Boolean)">
            <summary>
            Enumerates objects on the segment within the given memory range.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrSegment.GetGeneration(System.UInt64)">
            <summary>
            Returns the generation of an object in this segment.
            </summary>
            <param name="obj">An object in this segment.</param>
            <returns>
            The generation of the given object if that object lies in this segment.
            </returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrSegment.ToString">
            <summary>
            Returns a string representation of this object.
            </summary>
            <returns>A string representation of this object.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrStackFrame">
            <summary>
            A frame in a managed stack trace.  Note you can call ToString on an instance of this object to get the
            function name (or clr!Frame name) similar to SOS's !clrstack output.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrStackFrame.Thread">
            <summary>
            The thread parent of this frame.  Note that this may be null when inspecting the stack of ClrExceptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrStackFrame.Context">
            <summary>
            Gets this stack frame context.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrStackFrame.InstructionPointer">
            <summary>
            Gets the instruction pointer of this frame.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrStackFrame.StackPointer">
            <summary>
            Gets the stack pointer of this frame.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrStackFrame.Kind">
            <summary>
            Gets the type of frame (managed or internal).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrStackFrame.Method">
            <summary>
            Gets the <see cref="T:Microsoft.Diagnostics.Runtime.ClrMethod"/> which corresponds to the current stack frame.  This may be <see langword="null"/> if the
            current frame is actually a CLR "Internal Frame" representing a marker on the stack, and that
            stack marker does not have a managed method associated with it.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrStackFrame.FrameName">
            <summary>
            Gets the helper method frame name if <see cref="P:Microsoft.Diagnostics.Runtime.ClrStackFrame.Kind"/> is <see cref="F:Microsoft.Diagnostics.Runtime.ClrStackFrameKind.Runtime"/>, <see langword="null"/> otherwise.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrStackFrameKind">
            <summary>
            The type of frame the ClrStackFrame represents.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrStackFrameKind.Unknown">
            <summary>
            Indicates this stack frame is unknown
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrStackFrameKind.ManagedMethod">
            <summary>
            Indicates this stack frame is a standard managed method.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrStackFrameKind.Runtime">
            <summary>
            Indicates this stack frame is a special stack marker that the CLR leaves on the stack.
            Note that the <see cref="T:Microsoft.Diagnostics.Runtime.ClrStackFrame"/> may still have a <see cref="T:Microsoft.Diagnostics.Runtime.ClrMethod"/> associated with the marker.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrStaticField">
            <summary>
            Represents a static field in the target process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrStaticField.IsInitialized(Microsoft.Diagnostics.Runtime.ClrAppDomain)">
            <summary>
            Returns whether this static field has been initialized in a particular AppDomain
            or not.  If a static variable has not been initialized, then its class constructor
            may have not been run yet.  Calling any of the Read* methods on an uninitialized static
            will result in returning either NULL or a value of 0.
            </summary>
            <param name="appDomain">The AppDomain to see if the variable has been initialized.</param>
            <returns>
            True if the field has been initialized (even if initialized to NULL or a default
            value), false if the runtime has not initialized this variable.
            </returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrStaticField.GetAddress(Microsoft.Diagnostics.Runtime.ClrAppDomain)">
            <summary>
            Gets the address of the static field's value in memory.
            </summary>
            <returns>The address of the field's value.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrStaticField.Read``1(Microsoft.Diagnostics.Runtime.ClrAppDomain)">
            <summary>
            Reads the value of the field as an unmanaged struct or primitive type.
            </summary>
            <typeparam name="T">An unmanaged struct or primitive type.</typeparam>
            <returns>The value read.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrStaticField.ReadObject(Microsoft.Diagnostics.Runtime.ClrAppDomain)">
            <summary>
            Reads the value of an object field.
            </summary>
            <returns>The value read.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrStaticField.ReadStruct(Microsoft.Diagnostics.Runtime.ClrAppDomain)">
            <summary>
            Reads a ValueType struct from the instance field.
            </summary>
            <returns>The value read.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrStaticField.ReadString(Microsoft.Diagnostics.Runtime.ClrAppDomain)">
            <summary>
            Reads a string from the instance field.
            </summary>
            <returns>The value read.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrSubHeap">
            <summary>
            The managed heap in CLR is made up of a number of logical "heaps".  When using
            Workstation GC, the managed heap has only one logical "heap".  When using Server GC,
            there can be many of them.  This class tracks information about logical heaps.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrThinLock">
            <summary>
            An object's thinlock.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThinLock.Thread">
            <summary>
            The owning thread of this thinlock.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThinLock.Recursion">
            <summary>
            The recursion count of the entries for this thinlock.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrThread">
            <summary>
            Represents a managed thread in the target process.  Note this does not wrap purely native threads
            in the target process (that is, threads which have never run managed code before).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.Runtime">
            <summary>
            Gets the runtime associated with this thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.GCMode">
            <summary>
            Gets the suspension state of the thread according to the runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.Address">
            <summary>
            Gets the address of the underlying data structure which makes up the Thread object.  This
            serves as a unique identifier.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.State">
            <summary>
            The state of this thread.  These flags correspond to the runtime's internal flags on a thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsAlive">
            <summary>
            Returns true if the thread is alive in the process, false if this thread was recently terminated.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsFinalizer">
            <summary>
            Returns true if a finalizer thread otherwise false.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsGc">
            <summary>
            Returns true if a GC thread otherwise false.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.OSThreadId">
            <summary>
            Gets the OS thread id for the thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.ManagedThreadId">
            <summary>
            Gets the managed thread ID (this is equivalent to <see cref="P:System.Threading.Thread.ManagedThreadId"/>
            in the target process).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.CurrentAppDomain">
            <summary>
            Gets the AppDomain the thread is running in.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.LockCount">
            <summary>
            Gets the number of managed locks (Monitors) the thread has currently entered but not left.
            This will be highly inconsistent unless the process is stopped.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.StackBase">
            <summary>
            Gets the base of the stack for this thread, or 0 if the value could not be obtained.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.StackLimit">
            <summary>
            Gets the limit of the stack for this thread, or 0 if the value could not be obtained.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrThread.EnumerateStackRoots">
            <summary>
            Enumerates the GC references (objects) on the stack.
            </summary>
            <returns>An enumeration of GC references on the stack as the GC sees them.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrThread.EnumerateStackTrace(System.Boolean)">
            <summary>
            Enumerates a stack trace for a given thread.  Note this method may loop infinitely in the case of
            stack corruption or other stack unwind issues which can happen in practice.  When enumerating frames
            out of this method you should be careful to either set a maximum loop count, or to ensure the stack
            unwind is making progress by ensuring that ClrStackFrame.StackPointer is making progress (though it
            is expected that sometimes two frames may return the same StackPointer in some corner cases).
            </summary>
            <param name="includeContext">Whether to include a CONTEXT record for the frame.  This is always in
            the format of the Windows CONTEXT record (as that's what CLR uses internally, even on non-Windows
            platforms.</param>
            <returns>An enumeration of stack frames.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrThread.EnumerateStackTrace(System.Boolean,System.Int32)">
            <summary>
            Enumerates a stack trace for a given thread.  Note this method may loop infinitely in the case of
            stack corruption or other stack unwind issues which can happen in practice.  When enumerating frames
            out of this method you should be careful to either set a maximum loop count, or to ensure the stack
            unwind is making progress by ensuring that ClrStackFrame.StackPointer is making progress (though it
            is expected that sometimes two frames may return the same StackPointer in some corner cases).
            </summary>
            <param name="includeContext">Whether to include a CONTEXT record for the frame.  This is always in
            the format of the Windows CONTEXT record (as that's what CLR uses internally, even on non-Windows
            platforms.</param>
            <param name="maxFrames">The maximum number of stack frames to return.  It's important to cap the
            stack trace because sometimes bugs in the debugging layer or corruption in the target process
            can cause us to produce an infinite amount of stack frames.</param>
            <returns>An enumeration of stack frames.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.CurrentException">
            <summary>
            Gets the exception currently on the thread.  Note that this field may be <see langword="null"/>.  Also note
            that this is basically the "last thrown exception", and may be stale...meaning the thread could
            be done processing the exception but a crash dump was taken before the current exception was
            cleared off the field.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrThreadPool">
            <summary>
            Information about the CLR Runtime's ThreadPool.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.Initialized">
            <summary>
            Used to track whether we successfully initialized this object to prevent throw/catch.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.UsingPortableThreadPool">
            <summary>
            Whether this runtime is using the Portable threadpool or not.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.UsingWindowsThreadPool">
            <summary>
            Whether this runtime is using the Windows threadpool or not.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.CpuUtilization">
            <summary>
            The current CPU utilization of the ThreadPool (a number between 0 and 100).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.MinThreads">
            <summary>
            The minimum number of worker threads allowed for the ThreadPool.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.MaxThreads">
            <summary>
            The maximum number of worker threads allowed for the ThreadPool.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.IdleWorkerThreads">
            <summary>
            The number of idle worker threads.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.ActiveWorkerThreads">
            <summary>
            The number of active worker threads.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.RetiredWorkerThreads">
            <summary>
            The number of retired worker threads.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrThreadPool.EnumerateLegacyWorkRequests">
            <summary>
            Enumerates LegacyThreadPoolWorkRequests.  We only have this for Desktop CLR.
            </summary>
            <returns>An enumeration of work requests, or an empty enumeration of the runtime
            does not have them.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrThreadPool.EnumerateHillClimbingLog">
            <summary>
            Enumerates the ThreadPool's HillClimbing log.  This is the log of why we decided to add
            or remove threads from the ThreadPool.
            Note this is currently only supported on .Net Core and not Desktop CLR.
            </summary>
            <returns>An enumeration of the HillClimbing log, or an empty enumeration for Desktop CLR.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.HillClimbingLogEntry">
            <summary>
            An entry in the HillClimbing log.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.HillClimbingLogEntry.TickCount">
            <summary>
            The tick count of this entry.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.HillClimbingLogEntry.StateOrTransition">
            <summary>
            The new state.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.HillClimbingLogEntry.NewThreadCount">
            <summary>
            The new control setting.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.HillClimbingLogEntry.SampleCount">
            <summary>
            The last history count.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.HillClimbingLogEntry.Throughput">
            <summary>
            The last history mean.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.HillClimbingLogEntry.#ctor(System.Int32,Microsoft.Diagnostics.Runtime.HillClimbingTransition,System.Int32,System.Int32,System.Single)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrThreadStaticField.IsInitialized(Microsoft.Diagnostics.Runtime.ClrThread)">
            <summary>
            Returns whether this thread static field has been initialized on this thread
            or not.  If a static variable has not been initialized, then its class constructor
            may have not been run yet.  Calling any of the Read* methods on an uninitialized static
            will result in returning either NULL or a value of 0.
            </summary>
            <param name="thread">The thread to see if the variable has been initialized.</param>
            <returns>
            True if the field has been initialized (even if initialized to NULL or a default
            value), false if the runtime has not initialized this variable.
            </returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrThreadStaticField.GetAddress(Microsoft.Diagnostics.Runtime.ClrThread)">
            <summary>
            Gets the address of the static field's value in memory.
            </summary>
            <returns>The address of the field's value.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrThreadStaticField.Read``1(Microsoft.Diagnostics.Runtime.ClrThread)">
            <summary>
            Reads the value of the field as an unmanaged struct or primitive type.
            </summary>
            <typeparam name="T">An unmanaged struct or primitive type.</typeparam>
            <returns>The value read.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrThreadStaticField.ReadObject(Microsoft.Diagnostics.Runtime.ClrThread)">
            <summary>
            Reads the value of an object field.
            </summary>
            <returns>The value read.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrThreadStaticField.ReadStruct(Microsoft.Diagnostics.Runtime.ClrThread)">
            <summary>
            Reads a ValueType struct from the instance field.
            </summary>
            <returns>The value read.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrThreadStaticField.ReadString(Microsoft.Diagnostics.Runtime.ClrThread)">
            <summary>
            Reads a string from the instance field.
            </summary>
            <returns>The value read.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrType">
            <summary>
            A representation of a type in the target process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.Helpers">
            <summary>
            Used to provide functionality to ClrObject.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.GCDesc">
            <summary>
            Gets the <see cref="P:Microsoft.Diagnostics.Runtime.ClrType.GCDesc"/> associated with this type.  Only valid if <see cref="P:Microsoft.Diagnostics.Runtime.ClrType.ContainsPointers"/> is <see langword="true"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.MethodTable">
            <summary>
            Gets the MethodTable of this type (this is the TypeHandle if this is a type without a MethodTable).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.MetadataToken">
            <summary>
            Gets the metadata token of this type.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.Name">
            <summary>
            Gets the name of this type.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.ContainsPointers">
            <summary>
            Gets a value indicating whether the type <b>can</b> contain references to other objects.  This is used in optimizations
            and 'true' can always be returned safely.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsCollectible">
            <summary>
            Gets a value indicating whether this is a collectible type.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.LoaderAllocatorHandle">
            <summary>
            Gets the handle to the <c>LoaderAllocator</c> object for collectible types.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.AssemblyLoadContextAddress">
            <summary>
            Gets the address of the <c>AssemblyLoadContext</c> object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.Heap">
            <summary>
            Gets the <see cref="T:Microsoft.Diagnostics.Runtime.ClrHeap"/> this type belongs to.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.Module">
            <summary>
            Gets the module this type is defined in.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.ElementType">
            <summary>
            Gets the <see cref="T:Microsoft.Diagnostics.Runtime.ClrElementType"/> of this Type.  Can return <see cref="F:Microsoft.Diagnostics.Runtime.ClrElementType.Unknown"/> on error.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsPrimitive">
            <summary>
            Gets a value indicating whether this type is a primitive (<see cref="T:System.Int32"/>, <see cref="T:System.Single"/>, etc).
            </summary>
            <returns>True if this type is a primitive (<see cref="T:System.Int32"/>, <see cref="T:System.Single"/>, etc), false otherwise.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsValueType">
            <summary>
            Gets a value indicating whether this type is a value type.
            </summary>
            <returns>True if this type is a value type, false otherwise.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsObjectReference">
            <summary>
            Gets a value indicating whether this type is an object reference.
            </summary>
            <returns>True if this type is an object reference, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.EnumerateGenericParameters">
            <summary>
            Enumerates the generic parameters of this type.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.EnumerateInterfaces">
            <summary>
            Returns the list of interfaces this type implements.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.IsFinalizeSuppressed(System.UInt64)">
            <summary>
            Returns true if the finalization is suppressed for an object (the user program called
            <see cref="M:System.GC.SuppressFinalize(System.Object)"/>). The behavior of this function is undefined if the object itself
            is not finalizable.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsFinalizable">
            <summary>
            Gets a value indicating whether objects of this type are finalizable.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.TypeAttributes">
            <summary>
            Type attributes
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.Fields">
            <summary>
            Gets all possible fields in this type.   It does not return dynamically typed fields.
            Returns an empty list if there are no fields.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.StaticFields">
            <summary>
            Gets a list of static fields on this type.  Returns an empty list if there are no fields.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.ThreadStaticFields">
            <summary>
            Gets a list of thread static fields on this type.  Returns an empty list if there are no fields.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.Methods">
            <summary>
            Gets the list of methods this type implements.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetFieldByName(System.String)">
            <summary>
            Returns the field given by <paramref name="name"/>, case sensitive. Returns <see langword="null" /> if no such field name exists (or on error).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetStaticFieldByName(System.String)">
            <summary>
            Returns the field given by <paramref name="name"/>, case sensitive. Returns <see langword="null" /> if no such field name exists (or on error).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.BaseType">
            <summary>
            If this type inherits from another type, this is that type.  Can return <see langword="null"/> if it does not inherit (or is unknown).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsPointer">
            <summary>
            Gets a value indicating whether the type is in fact a pointer. If so, the pointer operators
            may be used.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.ComponentType">
            <summary>
            Gets the type of the element referenced by the pointer.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsArray">
            <summary>
            A type is an array if you can use the array operators below, Abstractly arrays are objects
            that whose children are not statically known by just knowing the type.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetArrayElementAddress(System.UInt64,System.Int32)">
            <summary>
            Returns the absolute address to the given array element.  You may then make a direct memory read out
            of the process to get the value if you want.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.ReadArrayElements``1(System.UInt64,System.Int32,System.Int32)">
            <summary>
            Returns multiple consecutive array element values.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.StaticSize">
            <summary>
            Gets the static size of objects of this type when they are created on the CLR heap.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.ComponentSize">
            <summary>
            Gets the size of elements of this object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsString">
            <summary>
            Gets a value indicating whether this type is <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsFree">
            <summary>
            Gets a value indicating whether this type represents free space on the heap.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsException">
            <summary>
            Gets a value indicating whether this type is an exception (that is, it derives from <see cref="T:System.Exception"/>).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsEnum">
            <summary>
            Gets a value indicating whether this type is an enum.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.AsEnum">
            <summary>
            Returns the <see cref="T:Microsoft.Diagnostics.Runtime.ClrEnum"/> representation of this type.
            </summary>
            <returns>The <see cref="T:Microsoft.Diagnostics.Runtime.ClrEnum"/> representation of this type.</returns>
            <exception cref="T:System.InvalidOperationException"><see cref="P:Microsoft.Diagnostics.Runtime.ClrType.IsEnum"/> is <see langword="false"/>.</exception>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsShared">
            <summary>
            Gets a value indicating whether this type is shared across multiple AppDomains.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.ToString">
            <summary>
            Returns a string representation of this object.
            </summary>
            <returns>A string representation of this object.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrValueType">
            <summary>
            Represents an instance of a type which inherits from <see cref="T:System.ValueType"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrValueType.Address">
            <summary>
            Gets the address of the object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrValueType.Type">
            <summary>
            Gets the type of the object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrValueType.IsValid">
            <summary>
            Returns whether this ClrValueType has a valid Type.  In most normal operations of ClrMD, we will have a
            non-null type.  However if we are missing metadata, or in some generic cases we might not be able to
            determine the type of this value type.  In those cases, Type? will be null and IsValid will return false.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrValueType.ReadObjectField(System.String)">
            <summary>
            Gets the given object reference field from this ClrObject.
            </summary>
            <param name="fieldName">The name of the field to retrieve.</param>
            <returns>A ClrObject of the given field.</returns>
            <exception cref="T:System.ArgumentException">
            The given field does not exist in the object.
            -or-
            The given field was not an object reference.
            </exception>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrValueType.ReadField``1(System.String)">
            <summary>
            Gets the value of a primitive field.  This will throw an InvalidCastException if the type parameter
            does not match the field's type.
            </summary>
            <typeparam name="T">The type of the field itself.</typeparam>
            <param name="fieldName">The name of the field.</param>
            <returns>The value of this field.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrValueType.ReadValueTypeField(System.String)">
            <summary>
            </summary>
            <param name="fieldName"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrValueType.ReadStringField(System.String,System.Int32)">
            <summary>
            Gets a string field from the object.  Note that the type must match exactly, as this method
            will not do type coercion.
            </summary>
            <param name="fieldName">The name of the field to get the value for.</param>
            <param name="maxLength">The maximum length of the string returned.  Warning: If the DataTarget
            being inspected has corrupted or an inconsistent heap state, the length of a string may be
            incorrect, leading to OutOfMemory and other failures.</param>
            <returns>The value of the given field.</returns>
            <exception cref="T:System.ArgumentException">No field matches the given name.</exception>
            <exception cref="T:System.InvalidOperationException">The field is not a string.</exception>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrValueType.TryReadStringField(System.String,System.Nullable{System.Int32},System.String@)">
            <summary>
            Tries to obtain the given string field from this ClrObject.  Returns false if the field wasn't found or if
            the underlying type was not a string..
            </summary>
            <param name="fieldName">The name of the field to retrieve.</param>
            <param name="maxLength">The string max length or the default.</param>
            <param name="result">True if the field was found and the field's type is a string.  Returns false otherwise.</param>
            <returns>A string of the given field.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ComCallableWrapper">
            <summary>
            Helper for COM Callable Wrapper objects.  (CCWs are CLR objects exposed to native code as COM
            objects).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ComCallableWrapper.IUnknown">
            <summary>
            Gets the pointer to the IUnknown representing this CCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ComCallableWrapper.Object">
            <summary>
            Gets the pointer to the managed object representing this CCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ComCallableWrapper.Handle">
            <summary>
            Gets the CLR handle associated with this CCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ComCallableWrapper.RefCount">
            <summary>
            Gets the refcount of this CCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ComCallableWrapper.Interfaces">
            <summary>
            Gets the interfaces that this CCW implements.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ComInterfaceData">
            <summary>
            The COM implementation details of a single CCW entry.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ComInterfaceData.Type">
            <summary>
            Gets the CLR type this represents.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ComInterfaceData.InterfacePointer">
            <summary>
            Gets the interface pointer of Type.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.CustomDataTarget">
            <summary>
            A user-defined data reader.
            Note that this class will be kept alive by <see cref="T:Microsoft.Diagnostics.Runtime.DataTarget"/> until <see cref="M:Microsoft.Diagnostics.Runtime.DataTarget.Dispose"/>
            is called.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.CustomDataTarget.DataReader">
            <summary>
            The data reader that ClrMD will use to read data from the target.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.CustomDataTarget.CacheOptions">
            <summary>
             An optional set of cache options.  Returning null from this property will use ClrMD's default
             cache options.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.CustomDataTarget.FileLocator">
            <summary>
            An optional file locator.  Returning null from this property will use ClrMD's file binary
            locator, which uses either <see cref="P:Microsoft.Diagnostics.Runtime.CustomDataTarget.DefaultSymbolPath"/> (if non null) or the _NT_SYMBOL_PATH (if
            <see cref="P:Microsoft.Diagnostics.Runtime.CustomDataTarget.DefaultSymbolPath"/> is null) environment variable to search for missing binaries.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.CustomDataTarget.DefaultSymbolPath">
            <summary>
            If <see cref="P:Microsoft.Diagnostics.Runtime.CustomDataTarget.FileLocator"/> is null, this path will be used as the symbol path for the default
            binary locator.  This property has no effect if <see cref="P:Microsoft.Diagnostics.Runtime.CustomDataTarget.FileLocator"/> is non-null.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.CustomDataTarget.#ctor(Microsoft.Diagnostics.Runtime.IDataReader)">
            <summary>
            Constructor.
            </summary>
            <param name="reader">A non-null IDataReader.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.CustomDataTarget.Dispose">
            <summary>
            Dispose method.  Called when <see cref="M:Microsoft.Diagnostics.Runtime.DataTarget.Dispose"/> is called.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.CustomDataTarget.Dispose(System.Boolean)">
            <summary>
            Dispose implementation.  The default implementation will call Dispose() on DataReader if
            it implements IDisposable.
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.DacInterface.ClrDataAddress">
            <summary>
            A representation of CLR's CLRDATA_ADDRESS, which is a signed 64bit integer.
            Unfortunately this can cause issues when inspecting 32bit processes, since
            if the highest bit is set the value will be sign-extended.  This struct is
            meant to
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DacInterface.ClrDataAddress.Value">
            <summary>
            Gets raw value of this address.  May be sign-extended if inspecting a 32bit process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DacInterface.ClrDataAddress.#ctor(System.Int64)">
            <summary>
            Creates an instance of ClrDataAddress.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DacInterface.ClrDataAddress.op_Implicit(Microsoft.Diagnostics.Runtime.DacInterface.ClrDataAddress)~System.UInt64">
            <summary>
            Returns the value of this address and un-sign extends the value if appropriate.
            </summary>
            <param name="cda">The address to convert.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DacInterface.ClrDataAddress.AsUInt64">
            <summary>
            Returns the value of this address and un-sign extends the value if appropriate.
            </summary>
            <returns>The value of this address and un-sign extends the value if appropriate.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.DacInterface.ClrDataProcess">
            <summary>
            This is an undocumented, untested, and unsupported interface.  Do not use.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DacInterface.DacDataTargetCOM.CreateIDacDataTarget(Microsoft.Diagnostics.Runtime.DacInterface.DacDataTarget)">
            <summary>
            Returns a COM pointer to an IDacDataTarget
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.DacInterface.SOSDac">
            <summary>
            This is an undocumented, untested, and unsupported interface.  Do not use.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.DacInterface.SosDac12">
            <summary>
            This is an undocumented, untested, and unsupported interface.  Do not use.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.DacInterface.SOSDac13">
            <summary>
            This is an undocumented, untested, and unsupported interface.  Do not use directly.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.DacInterface.SOSDac13.LoaderHeapKind">
            <summary>
            The type of the underlying loader heap.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.DacInterface.SOSDac13.LoaderHeapKind.LoaderHeapKindNormal">
            <summary>
            A LoaderHeap in the CLR codebase.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.DacInterface.SOSDac13.LoaderHeapKind.LoaderHeapKindExplicitControl">
            <summary>
            An ExplicitControlLoaderHeap in the CLR codebase.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.DacInterface.SOSDac13Old">
            <summary>
            This is an undocumented, untested, and unsupported interface.  Do not use directly.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.DacInterface.SOSDac6">
            <summary>
            This is an undocumented, untested, and unsupported interface.  Do not use.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.DacInterface.SOSDac8">
            <summary>
            This is an undocumented, untested, and unsupported interface.  Do not use.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.IDataReader">
            <summary>
            An interface for reading data out of the target process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.IDataReader.DisplayName">
            <summary>
            The name of the target.  This should be a meaningful moniker such as the pid of the target
            process or the path to the dump being read.  This is primarily used when debugging to see
            what DataTarget is inspecting.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.IDataReader.IsThreadSafe">
            <summary>
            Gets a value indicating whether this data reader is safe to use in parallel from multiple threads.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.IDataReader.TargetPlatform">
            <summary>
            The platform that the target process was running on.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.IDataReader.Architecture">
            <summary>
            Gets the architecture of the target.
            </summary>
            <returns>The architecture of the target.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.IDataReader.ProcessId">
            <summary>
            Gets the process ID of the DataTarget.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.EnumerateModules">
            <summary>
            Enumerates modules in the target process.
            </summary>
            <returns>An enumerable of the modules in the target process.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.GetThreadContext(System.UInt32,System.UInt32,System.Span{System.Byte})">
            <summary>
            Gets the thread context for the given thread.
            </summary>
            <param name="threadID">The OS thread ID to read the context from.</param>
            <param name="contextFlags">The requested context flags, or 0 for default flags.</param>
            <param name="context">A span to write the context to.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.FlushCachedData">
            <summary>
            Informs the data reader that the user has requested all data be flushed.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.IDumpInfoProvider">
             <summary>
             Provides auxillary information about a coredump or Windows minidump.
            
             This interface is not used by the ClrMD library itself, but is here to provide extra
             information and functionality to some tools consuming ClrMD.  You do not need to implement
             this interface when implementing IDataReader unless you are handing it to a tool which
             requires it.
            
             This inteface must always be requested and not assumed to be there:
            
                 IDataReader reader = ...;
            
                 if (reader is IDumpInfoProvider dumpInfoProvider)
                     ...
             </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.IDumpInfoProvider.IsMiniOrTriage">
            <summary>
            Returns whether the dump is a mini or triage dump (that is, full heap information was
            explicitly NOT placed into the dump).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.IMemoryReader.PointerSize">
            <summary>
            Gets the size of a pointer in the target process.
            </summary>
            <returns>The pointer size of the target process.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IMemoryReader.Read(System.UInt64,System.Span{System.Byte})">
            <summary>
            Read memory out of the target process.
            </summary>
            <param name="address">The address of memory to read.</param>
            <param name="buffer">The buffer to write to.</param>
            <returns>The number of bytes read into the buffer.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IMemoryReader.Read``1(System.UInt64,``0@)">
            <summary>
            Read an unmanaged value from the given address.
            </summary>
            <typeparam name="T">The type to read.  This may be a struct or primitive type as long as it does
            not managed pointers.</typeparam>
            <param name="address">The address to read from.</param>
            <param name="value">The value that was read.</param>
            <returns>True if the memory was present, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IMemoryReader.Read``1(System.UInt64)">
            <summary>
            Read an unmanaged value from the given address.  Returns default(T) if the data was not readable.
            </summary>
            <typeparam name="T">The type to read.  This may be a struct or primitive type as long as it does
            not managed pointers.</typeparam>
            <param name="address">The address to read from.</param>
            <returns>The value at addr, or default(T) if not present in the data target.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IMemoryReader.ReadPointer(System.UInt64,System.UInt64@)">
            <summary>
            Reads a pointer at the given address.
            </summary>
            <param name="address">The address to read from.</param>
            <param name="value">A pointer sized value that was read.</param>
            <returns>True if the value was read, false if the value could not be read.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IMemoryReader.ReadPointer(System.UInt64)">
            <summary>
            Read a pointer out of the target process.
            </summary>
            <returns>
            The pointer at the give address, or 0 if that pointer doesn't exist in
            the data target.
            </returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.DataReaders.Implementation.IThreadReader">
             <summary>
             This interface is implemented by all ClrMD provided implementations of <see cref="T:Microsoft.Diagnostics.Runtime.IDataReader"/>.
             This interface is not used by the ClrMD library itself, but is here to maintain functionality
             for previous uses of these functions in ClrMD 1.1's <see cref="T:Microsoft.Diagnostics.Runtime.IDataReader"/>.
            
             This inteface must always be requested and not assumed to be there:
            
                 IDataReader reader = ...;
            
                 if (reader is IThreadReader threadReader)
                     ...
             </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataReaders.Implementation.IThreadReader.EnumerateOSThreadIds">
            <summary>
            Enumerates the thread ids of all live threads in the target process.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataReaders.Implementation.IThreadReader.GetThreadTeb(System.UInt32)">
            <summary>
            Obtains the Windows specific Thread Execution Block.
            </summary>
            <param name="osThreadId"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Arm64Context">
            <summary>
            ARM-specific thread context.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ArmContext">
            <summary>
            ARM-specific thread context.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Float80">
            <summary>
            Float in X86-specific windows thread context.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RegisterAttribute.Name">
            <summary>
            Gets or sets optional name override
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RegisterAttribute.RegisterType">
            <summary>
            Gets register type and flags
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.RiscV64Context">
            <summary>
            RISC-V-specific thread context.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.X86Context">
            <summary>
            X86-specific windows thread context.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.DataTarget">
            <summary>
            A crash dump or live process to read out of.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.AddClrInfoProvider(Microsoft.Diagnostics.Runtime.IClrInfoProvider)">
            <summary>
            Adds an IClrInfoProvider to DataTarget.  There are no guarantees on order in which they are called.
            </summary>
            <param name="clrInfoProvider">The provider to add.</param>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DataTarget.DataReader">
            <summary>
            Gets the data reader for this instance.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DataTarget.CacheOptions">
            <summary>
            The caching options for ClrMD.  This controls what kinds of memory we cache and what values have to be
            recalculated on every call.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DataTarget.FileLocator">
            <summary>
            Gets or sets instance to manage the symbol path(s).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.#ctor(Microsoft.Diagnostics.Runtime.CustomDataTarget)">
            <summary>
            Creates a DataTarget from the given reader.
            </summary>
            <param name="customTarget">The custom data target to use.</param>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DataTarget.ClrVersions">
            <summary>
            Gets the list of CLR versions loaded into the process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.EnumerateModules">
            <summary>
            Enumerates information about the loaded modules in the process (both managed and unmanaged).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DataTarget.PlatformFunctions">
            <summary>
            Gets a set of helper functions that are consistently implemented across all platforms.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.LoadDump(System.String,System.IO.Stream,Microsoft.Diagnostics.Runtime.CacheOptions,System.Boolean)">
            <summary>
            Loads a dump stream. Currently supported formats are Mach-O coredump, ELF coredump, and Windows Minidump formats.
            </summary>
            <param name="displayName">The name of this DataTarget, might be used in exceptions.</param>
            <param name="stream">The stream that should be used.</param>
            <param name="cacheOptions">The caching options to use. (Only used for FileStreams)</param>
            <param name="leaveOpen">True whenever the given stream should be leaved open when the DataTarget is disposed.</param>
            <returns>A <see cref="T:Microsoft.Diagnostics.Runtime.DataTarget"/> for the given dump.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.LoadDump(System.String)">
            <summary>
            Loads a dump file. Currently supported formats are Mach-O coredump, ELF coredump, and Windows Minidump formats.
            </summary>
            <param name="filePath">The path to the dump file.</param>
            <returns>A <see cref="T:Microsoft.Diagnostics.Runtime.DataTarget"/> for the given dump file.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.LoadDump(System.String,Microsoft.Diagnostics.Runtime.CacheOptions)">
            <summary>
            Loads a dump file. Currently supported formats are Mach-O coredump, ELF coredump, and Windows Minidump formats.
            </summary>
            <param name="filePath">The path to the dump file.</param>
            <param name="cacheOptions">The caching options to use.</param>
            <returns>A <see cref="T:Microsoft.Diagnostics.Runtime.DataTarget"/> for the given dump file.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.AttachToProcess(System.Int32,System.Boolean)">
            <summary>
            Attaches to a running process.  Note that if <paramref name="suspend"/> is set to false the user
            of ClrMD is still responsible for suspending the process itself.  ClrMD does NOT support inspecting
            a running process and will produce undefined behavior when attempting to do so.
            </summary>
            <param name="processId">The ID of the process to attach to.</param>
            <param name="suspend">Whether or not to suspend the process.</param>
            <returns>A <see cref="T:Microsoft.Diagnostics.Runtime.DataTarget"/> instance.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.CreateSnapshotAndAttach(System.Int32)">
             <summary>
             Creates a snapshot of a running process and attaches to it.  This method will pause a running process
            
             </summary>
             <param name="processId">The ID of the process to attach to.</param>
             <returns>A <see cref="T:Microsoft.Diagnostics.Runtime.DataTarget"/> instance.</returns>
             <exception cref="T:System.ArgumentException">
             The process specified by <paramref name="processId"/> is not running.
             </exception>
             <exception cref="T:System.PlatformNotSupportedException">
             The current platform is not Windows.
             </exception>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.CreateFromDbgEng(System.IntPtr)">
            <summary>
            Creates a DataTarget from an IDebugClient interface.  This allows callers to interop with the DbgEng debugger
            (cdb.exe, windbg.exe, dbgeng.dll).
            </summary>
            <param name="pDebugClient">An IDebugClient interface.</param>
            <returns>A <see cref="T:Microsoft.Diagnostics.Runtime.DataTarget"/> instance.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.DebugLibraryInfo">
            <summary>
            This class provides information about CLR debugging artifacts.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DebugLibraryInfo.Kind">
            <summary>
            The kind of debugging library this is.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DebugLibraryInfo.FileName">
            <summary>
            Gets the platform specific filename of the debugging library.
            This may be a full path on disk if we find that this machine has the file locally.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DebugLibraryInfo.TargetArchitecture">
            <summary>
            Gets the architecture of this debugging library.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DebugLibraryInfo.ArchivedUnder">
            <summary>
            Returns what properties that this dac library is archived under.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DebugLibraryInfo.IndexFileSize">
            <summary>
            Gets the specific file size of the image used to index it on the symbol server.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DebugLibraryInfo.IndexTimeStamp">
            <summary>
            Gets the timestamp of the image used to index it on the symbol server.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DebugLibraryInfo.IndexBuildId">
            <summary>
            The BuildId that this library is indexed under (or IsEmptyOrDefault otherwise).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DebugLibraryInfo.Platform">
            <summary>
            The platform that this library was designed to run on.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DebugLibraryInfo.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DebugLibraryInfo.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DebugLibraryInfo.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.MemoryExtensions">
            <summary>
            A set of extension methods to help when dealing with memory.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.MemoryExtensions.SearchMemory(Microsoft.Diagnostics.Runtime.IMemoryReader,System.UInt64,System.Int32,System.ReadOnlySpan{System.Byte})">
            <summary>
            Searches memory from startAddress to endAddress, looking for the memory specified by `searchFor`.  Note
            that this is NOT meant to be used to search the entire address space.  This method will attempt to read
            all memory from startAddress to endAddress, so providing very large ranges of memory will make this take
            a long time.
            </summary>
            <param name="reader">The memory reader to search through.</param>
            <param name="startAddress">The address to start searching memory.</param>
            <param name="length">The length of memory to search.</param>
            <param name="searchFor">The memory to search for.</param>
            <returns>The address of the value if found, 0 if not found.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.GCMode">
            <summary>
            Defines the state of the thread from the runtime's perspective.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCMode.Cooperative">
            <summary>
            In Cooperative mode the thread must cooperate before a GC may proceed.  This means when a GC
            starts, the runtime will attempt to suspend the thread at a safepoint but cannot immediately
            stop the thread until it synchronizes.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCMode.Preemptive">
            <summary>
            In Preemptive mode the runtime is free to suspend the thread at any time for a GC to occur.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.GCRoot.ChainLink">
            <summary>
            An entry in the rooting chain.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.GCRoot.ChainLink.Object">
            <summary>
            The address of the object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.GCRoot.ChainLink.Next">
            <summary>
            The next object in the sequence.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.GCSegmentKind">
            <summary>
            The kind of GC Segment or region.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCSegmentKind.Generation0">
            <summary>
            This "segment" is actually a GC Gen0 region.  This is only enumerated
            when the GC regions feature is present in the target CLR.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCSegmentKind.Generation1">
            <summary>
            This "segment" is actually a GC Gen1 region.  This is only enumerated
            when the GC regions feature is present in the target CLR.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCSegmentKind.Generation2">
            <summary>
            This segment contains only Gen2 objects.  This may be a segment or
            region.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCSegmentKind.Large">
            <summary>
            A large object segment.  Objects here are above a certain size (usually
            85,000 bytes) and all objects here are pinned.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCSegmentKind.Pinned">
            <summary>
            Pinned object segment.  All objects here are pinned.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCSegmentKind.Frozen">
            <summary>
            This segment is frozen, meaning it is both pinned and no objects will
            ever be collected.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCSegmentKind.Ephemeral">
            <summary>
            An Ephemeral segment is one which has Gen0, Gen1, and Gen2 sections.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Generation">
            <summary>
            The "generation" of an object.  Note that this is a simulated view
            of what a "generation" is.  For example, Large objects are still
            considered gen2 for GC collection purposes.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Generation.Generation0">
            <summary>
            Gen0 objects.  These may reside on an Ephemeral segment, or
            on a Gen0 region.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Generation.Generation1">
            <summary>
            Gen1 objects.  These may reside on an Ephemeral segment, or
            on a Gen1 region.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Generation.Generation2">
            <summary>
            Gen2 objects.  These may reside on an Ephemeral segment, or
            on a Gen2 region.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Generation.Large">
            <summary>
            Objects on the Large Object Heap, considered gen2 for collection.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Generation.Pinned">
            <summary>
            Objects on the Pinned Object Heap, considered gen2 for collection.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Generation.Frozen">
            <summary>
            Frozen objects will never be collected.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Generation.Unknown">
            <summary>
            Unknown object generation.  Could be a bug within ClrMD or a sign
            of heap corruption.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.HillClimbingTransition">
            <summary>
            The state or transition which triggered a HillClimbing change.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.HotColdRegions">
            <summary>
            Returns the addresses and sizes of the hot and cold regions of a method.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.HotColdRegions.HotStart">
            <summary>
            Gets the start address of the method's hot region.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.HotColdRegions.HotSize">
            <summary>
            Gets the size of the hot region.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.HotColdRegions.ColdStart">
            <summary>
            Gets the start address of the method's cold region.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.HotColdRegions.ColdSize">
            <summary>
            Gets the size of the cold region.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IClrInfoProvider.ProvideClrInfoForModule(Microsoft.Diagnostics.Runtime.DataTarget,Microsoft.Diagnostics.Runtime.ModuleInfo)">
            <summary>
            Inspect the given module and if it's a CLR runtime module, provide a ClrInfo for it.
            </summary>
            <param name="dataTarget">The DataTarget for the given module.</param>
            <param name="module">The module to inspect.</param>
            <returns>A ClrInfo if module is a CLR runtime, null otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IClrInfoProvider.GetDacServices(Microsoft.Diagnostics.Runtime.ClrInfo,System.String,System.Boolean)">
            <summary>
            Creates an instance of an <see cref="T:System.IServiceProvider"/> for the given <see cref="T:Microsoft.Diagnostics.Runtime.ClrInfo"/>.
            Note that this will only be called on the interface which previously provided the given ClrInfo.
            </summary>
            <param name="clrInfo">A ClrInfo previously returned by this same instance.</param>
            <param name="providedPath">The path provided to DataTarget.CreateRuntime.</param>
            <param name="ignorePathMismatch">The ignore mismatch parameter provided to DataTarget.CreateRuntime.</param>
            <returns>An <see cref="T:System.IServiceProvider"/> interface to use with the specified clr runtime that provides
            <see cref="T:Microsoft.Diagnostics.Runtime.AbstractDac.IAbstractRuntime"/> related services.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.IFileLocator">
            <summary>
            An implementation of
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IFileLocator.FindPEImage(System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Locates a PE Image archived under the given properties.
            </summary>
            <param name="fileName">The file name or path of the binary to locate.</param>
            <param name="buildTimeStamp">The build timestamp the binary is indexed under.</param>
            <param name="imageSize">The image size the binary is indexed under.</param>
            <param name="checkProperties">Whether or not to validate the properties of the binary after download.</param>
            <returns>A full path on disk (local) of where the binary was copied to or <see langword="null"/> if it was not found.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IFileLocator.FindPEImage(System.String,Microsoft.Diagnostics.Runtime.SymbolProperties,System.Collections.Immutable.ImmutableArray{System.Byte},System.Runtime.InteropServices.OSPlatform,System.Boolean)">
            <summary>
            Locates a PE Image potentially archived under an ELF or Mach-O binary's properties.
            </summary>
            <param name="fileName">The file name or path of the binary to locate.</param>
            <param name="archivedUnder">The file or keyword that this binary is archived under.</param>
            <param name="buildIdOrUUID">The buildId or UUID of the binary specified by <paramref name="archivedUnder"/>.</param>
            <param name="originalPlatform">The platform of the binary specified by <paramref name="archivedUnder"/>.</param>
            <param name="checkProperties">Whether or not to validate the properties of the binary after download.</param>
            <returns>A full path on disk (local) of where the binary was copied to or <see langword="null"/> if it was not found.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IFileLocator.FindElfImage(System.String,Microsoft.Diagnostics.Runtime.SymbolProperties,System.Collections.Immutable.ImmutableArray{System.Byte},System.Boolean)">
            <summary>
            Locates an Elf binary.
            </summary>
            <param name="fileName">The file name or path of the binary to locate.</param>
            <param name="archivedUnder">The file or keyword that this binary is archived under, <see langword="null"/> if its archived under its own properties.</param>
            <param name="buildId">The buildId of the Elf image to locate or the buildId of the image specified by <paramref name="archivedUnder"/>.</param>
            <param name="checkProperties">Whether or not to validate that the given file matches the build id.</param>
            <returns>A full path on disk (local) of where the binary was copied to or <see langword="null"/> if it was not found.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IFileLocator.FindMachOImage(System.String,Microsoft.Diagnostics.Runtime.SymbolProperties,System.Collections.Immutable.ImmutableArray{System.Byte},System.Boolean)">
             <summary>
            
             </summary>
             <param name="fileName">The file name or path of the binary to locate.</param>
             <param name="archivedUnder">The file or keyword that this binary is archived under, <see langword="null"/> if its archived under its own properties.</param>
             <param name="uuid">The UUID of the image or of the image specified by <paramref name="archivedUnder"/>.</param>
             <param name="checkProperties">Whether or not to validate that the given file matches the uuid.</param>
             <returns>A full path on disk (local) of where the binary was copied to or <see langword="null"/> if it was not found.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ILInfo">
            <summary>
            Returns information about the IL for a method.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ILInfo.Address">
            <summary>
            Gets the address in memory of where the IL for a particular method is located.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ILInfo.Length">
            <summary>
            Gets the length (in bytes) of the IL method body.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ILInfo.Flags">
            <summary>
            Gets the flags associated with the IL code.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ILInfo.LocalVarSignatureToken">
            <summary>
            Gets the local variable signature token for this IL method.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ILToNativeMap">
            <summary>
            A method's mapping from IL to native offsets.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ILToNativeMap.ILOffset">
            <summary>
            The IL offset for this entry.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ILToNativeMap.StartAddress">
            <summary>
            The native start offset of this IL entry.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ILToNativeMap.EndAddress">
            <summary>
            The native end offset of this IL entry.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ILToNativeMap.ToString">
            <summary>
            To string.
            </summary>
            <returns>A visual display of the map entry.</returns>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ILToNativeMap._reserved">
            <summary>
            Reserved.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Implementation.ClrGenericType">
            <summary>
            This represents a ClrType for which we cannot get information from the dac.  In theory we shouldn't need this
            type, but in practice there are fields which do not report a type.  This allows us to provide a non-null, semi
            meaningful type even though it's not as accurate or specific as we wish it would be.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Implementation.ElfModuleInfo.BuildId">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Implementation.ElfModuleInfo.Version">
            <inheritdoc/>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Implementation.FileLocatorBase">
            <summary>
            A base file locator, each method only builds the key under which a file is located.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Implementation.PEModuleInfo">
            <summary>
            A helper to implement <see cref="T:Microsoft.Diagnostics.Runtime.ModuleInfo"/> for PEImages.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Implementation.PEModuleInfo.Version">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Implementation.PEModuleInfo.Pdb">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Implementation.PEModuleInfo.IsManaged">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Implementation.PEModuleInfo.IndexFileSize">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Implementation.PEModuleInfo.IndexTimeStamp">
            <inheritdoc/>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Interfaces.IClrAppDomain">
            <summary>
            <see cref="T:Microsoft.Diagnostics.Runtime.ClrAppDomain"/>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Interfaces.IClrAppDomain.Address">
            <summary>
            <see cref="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.Address"/>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Interfaces.IClrAppDomain.ApplicationBase">
            <summary>
            <see cref="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.ApplicationBase"/>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Interfaces.IClrAppDomain.ConfigurationFile">
            <summary>
            <see cref="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.ConfigurationFile"/>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Interfaces.IClrAppDomain.Id">
            <summary>
            <see cref="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.Id"/>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Interfaces.IClrAppDomain.LoaderAllocator">
            <summary>
            <see cref="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.LoaderAllocator"/>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Interfaces.IClrAppDomain.Modules">
            <summary>
            <see cref="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.Modules"/>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Interfaces.IClrAppDomain.Name">
            <summary>
            <see cref="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.Name"/>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Interfaces.IClrAppDomain.Runtime">
            <summary>
            <see cref="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.Runtime"/>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Interfaces.IClrAppDomain.EnumerateLoaderAllocatorHeaps">
            <summary>
            <see cref="M:Microsoft.Diagnostics.Runtime.ClrAppDomain.EnumerateLoaderAllocatorHeaps"/>
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Interfaces.IClrModule">
            <summary>
            <see cref="T:Microsoft.Diagnostics.Runtime.ClrModule"/>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Interfaces.IClrModule.Address">
            <summary>
            <see cref="P:Microsoft.Diagnostics.Runtime.ClrModule.Address"/>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Interfaces.IClrModule.AppDomain">
            <summary>
            <see cref="P:Microsoft.Diagnostics.Runtime.ClrModule.AppDomain"/>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Interfaces.IClrModule.AssemblyAddress">
            <summary>
            <see cref="P:Microsoft.Diagnostics.Runtime.ClrModule.AssemblyAddress"/>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Interfaces.IClrModule.AssemblyName">
            <summary>
            <see cref="P:Microsoft.Diagnostics.Runtime.ClrModule.AssemblyName"/>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Interfaces.IClrModule.DebuggingMode">
            <summary>
            <see cref="P:Microsoft.Diagnostics.Runtime.ClrModule.DebuggingMode"/>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Interfaces.IClrModule.ImageBase">
            <summary>
            <see cref="P:Microsoft.Diagnostics.Runtime.ClrModule.ImageBase"/>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Interfaces.IClrModule.IsDynamic">
            <summary>
            <see cref="P:Microsoft.Diagnostics.Runtime.ClrModule.IsDynamic"/>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Interfaces.IClrModule.IsPEFile">
            <summary>
            <see cref="P:Microsoft.Diagnostics.Runtime.ClrModule.IsPEFile"/>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Interfaces.IClrModule.Layout">
            <summary>
            <see cref="P:Microsoft.Diagnostics.Runtime.ClrModule.Layout"/>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Interfaces.IClrModule.LoaderAllocator">
            <summary>
            <see cref="P:Microsoft.Diagnostics.Runtime.ClrModule.LoaderAllocator"/>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Interfaces.IClrModule.MetadataAddress">
            <summary>
            <see cref="P:Microsoft.Diagnostics.Runtime.ClrModule.MetadataAddress"/>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Interfaces.IClrModule.MetadataLength">
            <summary>
            <see cref="P:Microsoft.Diagnostics.Runtime.ClrModule.MetadataLength"/>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Interfaces.IClrModule.Name">
            <summary>
            <see cref="P:Microsoft.Diagnostics.Runtime.ClrModule.Name"/>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Interfaces.IClrModule.Pdb">
            <summary>
            <see cref="P:Microsoft.Diagnostics.Runtime.ClrModule.Pdb"/>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Interfaces.IClrModule.Size">
            <summary>
            <see cref="P:Microsoft.Diagnostics.Runtime.ClrModule.Size"/>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Interfaces.IClrModule.ThunkHeap">
            <summary>
            <see cref="P:Microsoft.Diagnostics.Runtime.ClrModule.ThunkHeap"/>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Interfaces.IClrModule.EnumerateLoaderAllocatorHeaps">
            <summary>
            <see cref="M:Microsoft.Diagnostics.Runtime.ClrModule.EnumerateLoaderAllocatorHeaps"/>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Interfaces.IClrModule.EnumerateThunkHeap">
            <summary>
            <see cref="M:Microsoft.Diagnostics.Runtime.ClrModule.EnumerateThunkHeap"/>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Interfaces.IClrModule.EnumerateTypeDefToMethodTableMap">
            <summary>
            <see cref="M:Microsoft.Diagnostics.Runtime.ClrModule.EnumerateTypeDefToMethodTableMap"/>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Interfaces.IClrModule.EnumerateTypeRefToMethodTableMap">
            <summary>
            <see cref="M:Microsoft.Diagnostics.Runtime.ClrModule.EnumerateTypeRefToMethodTableMap"/>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Interfaces.IClrModule.GetTypeByName(System.String)">
            <summary>
            <see cref="M:Microsoft.Diagnostics.Runtime.ClrModule.GetTypeByName(System.String)"/>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Interfaces.IClrRuntime.ThreadPool">
            <summary>
            Gets information about CLR's ThreadPool.  May return null if we could not obtain
            ThreadPool data from the target process or dump.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Interfaces.IClrThreadPool.UsingPortableThreadPool">
            <summary>
            Whether this runtime is using the Portable threadpool or not.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Interfaces.IClrThreadPool.UsingWindowsThreadPool">
            <summary>
            Whether this runtime is using the Windows threadpool or not.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Interfaces.IClrThreadPool.CpuUtilization">
            <summary>
            The current CPU utilization of the ThreadPool (a number between 0 and 100).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Interfaces.IClrThreadPool.MinThreads">
            <summary>
            The minimum number of worker threads allowed for the ThreadPool.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Interfaces.IClrThreadPool.MaxThreads">
            <summary>
            The maximum number of worker threads allowed for the ThreadPool.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Interfaces.IClrThreadPool.IdleWorkerThreads">
            <summary>
            The number of idle worker threads.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Interfaces.IClrThreadPool.ActiveWorkerThreads">
            <summary>
            The number of active worker threads.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Interfaces.IClrThreadPool.RetiredWorkerThreads">
            <summary>
            The number of retired worker threads.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Interfaces.IClrThreadPool.EnumerateLegacyWorkRequests">
            <summary>
            Enumerates LegacyThreadPoolWorkRequests.  We only have this for Desktop CLR.
            </summary>
            <returns>An enumeration of work requests, or an empty enumeration of the runtime
            does not have them.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Interfaces.IClrThreadPool.EnumerateHillClimbingLog">
            <summary>
            Enumerates the ThreadPool's HillClimbing log.  This is the log of why we decided to add
            or remove threads from the ThreadPool.
            Note this is currently only supported on .Net Core and not Desktop CLR.
            </summary>
            <returns>An enumeration of the HillClimbing log, or an empty enumeration for Desktop CLR.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.IResourceNode">
            <summary>
            Represents a single resource node in a resource tree.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.IResourceNode.Children">
            <summary>
            The Children of this resource node.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.IResourceNode.Name">
            <summary>
            The name of this entry (may be null).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.IResourceNode.Size">
            <summary>
            The size of the data carried by this resource node.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IResourceNode.Read(System.Span{System.Byte},System.Int32)">
            <summary>
            Reads the data out of this resource node.
            </summary>
            <param name="buffer">The buffer to read the data into.</param>
            <param name="offset">The offset into the data to read.</param>
            <returns>The number of bytes read into buffer.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IResourceNode.Read``1(System.Int32)">
            <summary>
            Reads the data out of this resource node into T.
            </summary>
            <typeparam name="T">An unmanaged struct to read the data into.</typeparam>
            <param name="offset">The offset into the data to read.</param>
            <returns>The data read, or <see langword="default"/> if we failed to read this data.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IResourceNode.GetChild(System.String)">
            <summary>
            Returns the first child resource node that matches <paramref name="name"/>, or null if one doesn't exist.
            </summary>
            <param name="name">The name of the child node.</param>
            <returns>The matching resource node, or null if it doesn't exist.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.LegacyThreadPoolWorkRequest">
            <summary>
            A legacy ThreadPool work request item.  This is only relevant for DesktopCLR.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.ElfCoreFile">
            <summary>
            A helper class to read linux coredumps.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfCoreFile.ElfFile">
            <summary>
            All coredumps are themselves ELF files.  This property returns the ElfFile that represents this coredump.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.ElfCoreFile.EnumeratePRStatus">
            <summary>
            Enumerates all prstatus notes contained within this coredump.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.ElfCoreFile.GetAuxvValue(Microsoft.Diagnostics.Runtime.Utilities.ElfAuxvType)">
            <summary>
            Returns the Auxv value of the given type.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfCoreFile.LoadedImages">
            <summary>
            A mapping of all loaded images in the process.  The key is the base address that the module is loaded at.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.ElfCoreFile.#ctor(System.String)">
            <summary>
            Creates an ElfCoreFile from a file on disk.
            </summary>
            <param name="coredump">A full path to a coredump on disk.</param>
            <exception cref="T:System.IO.InvalidDataException">Throws <see cref="T:System.IO.InvalidDataException"/> if the file is not an Elf coredump.</exception>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.ElfCoreFile.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            Creates an ElfCoreFile from a file on disk.
            </summary>
            <param name="stream">The Elf stream to read the coredump from.</param>
            <param name="leaveOpen">Whether to leave the given stream open after this class is disposed.</param>
            <exception cref="T:System.IO.InvalidDataException">Throws <see cref="T:System.IO.InvalidDataException"/> if the file is not an Elf coredump.</exception>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.ElfCoreFile.ReadMemory(System.UInt64,System.Span{System.Byte})">
            <summary>
            Reads memory from the given coredump's virtual address space.
            </summary>
            <param name="address">An address in the target program's virtual address space.</param>
            <param name="buffer">The buffer to fill.</param>
            <returns>The number of bytes written into the buffer.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.ElfFile">
            <summary>
            A helper class to read ELF files.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfFile.Header">
            <summary>
            The ElfHeader of this file.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfFile.Notes">
            <summary>
            The list of ElfNotes for this file.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfFile.ProgramHeaders">
            <summary>
            The list of ProgramHeaders for this file.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.ElfFile.TryGetExportSymbol(System.String,System.UInt64@)">
            <summary>
            Returns the address of a module export symbol if found
            </summary>
            <param name="symbolName">symbol name (without the module name prepended)</param>
            <param name="offset">symbol offset returned</param>
            <returns>true if found</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfFile.DynamicSection">
            <summary>
            The ELFDynamicSection for this file, if it exists.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfFile.BuildId">
            <summary>
            Returns the build id of this ELF module (or ImmutableArray.Default if it doesn't exist).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.ElfFile.#ctor(System.String)">
            <summary>
            Creates an ElfFile from a file on disk.
            </summary>
            <param name="filename">A full path of an elf file on disk.</param>
            <exception cref="T:System.IO.InvalidDataException">Throws <see cref="T:System.IO.InvalidDataException"/> if the file is not an Elf coredump.</exception>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.ElfFile.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            Creates an ElfFile from a file on disk.
            </summary>
            <param name="stream">The Elf stream to read the Elf file from.</param>
            <param name="leaveOpen">Whether to leave the given stream open after this class is disposed.</param>
            <exception cref="T:System.IO.InvalidDataException">Throws <see cref="T:System.IO.InvalidDataException"/> if the file is not an Elf file.</exception>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.ElfFile.#ctor(System.IO.Stream,System.UInt64,System.Boolean,System.Boolean)">
            <summary>
            Creates an ElfFile from a file on disk.
            </summary>
            <param name="stream">The Elf stream to read the Elf file from.</param>
            <param name="position">Base position of streawm</param>
            <param name="leaveOpen">Whether to leave the given stream open after this class is disposed.</param>
            <param name="isVirtual">Whether stream points to a ELF image mapped into an address space (such as in a live process or crash dump).</param>
            <exception cref="T:System.IO.InvalidDataException">Throws <see cref="T:System.IO.InvalidDataException"/> if the file is not an Elf file.</exception>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.ElfLoadedImage">
            <summary>
            A representation of an ELF loaded image section.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfLoadedImage.BaseAddress">
            <summary>
            The BaseAddress of this image
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfLoadedImage.Size">
            <summary>
            The size of this image in memory.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.ElfLoadedImage.Open">
            <summary>
            Open the loaded image as an ELFFile.
            </summary>
            <returns>An ELFFile if this is a valid ELF image, null otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.ElfLoadedImage.AsStream">
            <summary>
            Returns this ELF loaded image as a stream.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.ElfLoadedImage.ToString">
            <summary>
            Returns <see cref="P:Microsoft.Diagnostics.Runtime.Utilities.ElfLoadedImage.FileName"/>.
            </summary>
            <returns><see cref="P:Microsoft.Diagnostics.Runtime.Utilities.ElfLoadedImage.FileName"/></returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.ElfNote">
            <summary>
            A helper class to represent an ELF note section.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfNote.ContentSize">
            <summary>
            The content size of the data stored within this note.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfNote.Type">
            <summary>
            The type of note this is.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfNote.Name">
            <summary>
            The note's name.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.ElfNote.ReadContents(System.UInt64,System.Span{System.Byte})">
            <summary>
            Reads the contents of this note file.
            </summary>
            <param name="position">The position within the note to read from.</param>
            <param name="buffer">The buffer to read the note into.</param>
            <returns>The number of bytes read written to buffer.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.ElfNote.ReadContents``1(System.UInt64)">
            <summary>
            Reads the contents of this note file.
            </summary>
            <param name="position">The position within the note to read from.</param>
            <exception cref="T:System.IO.IOException">If the data could not be read.</exception>
            <returns>The data at the given position.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.ElfProgramHeader">
            <summary>
            A helper class to represent ELF program headers.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfProgramHeader.Type">
            <summary>
            The type of header this is.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfProgramHeader.VirtualAddress">
            <summary>
            The VirtualAddress of this header.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfProgramHeader.VirtualSize">
            <summary>
            The size of this header.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfProgramHeader.FileOffset">
            <summary>
            The offset of this header within the file.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfProgramHeader.FileSize">
            <summary>
            The size of this header within the file.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfProgramHeader.IsExecutable">
            <summary>
            Whether this section of memory is executable.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfProgramHeader.IsWritable">
            <summary>
            Whether this section of memory is writable.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.IElfHeader">
            <summary>
            An abstract version of 32 and 64 bit ELF headers.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.IElfHeader.Is64Bit">
            <summary>
            Whether this file is 64 bit or not.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.IElfHeader.IsValid">
            <summary>
            Whether this file contains the magic header at the right offset or not.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.IElfHeader.Type">
            <summary>
            The type of ELF file.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.IElfHeader.Architecture">
            <summary>
            The architecture of the ELF file.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.IElfHeader.ProgramHeaderOffset">
            <summary>
            The offset of the program header.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.IElfHeader.SectionHeaderOffset">
            <summary>
            The offset of the section header.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.IElfHeader.ProgramHeaderEntrySize">
            <summary>
            The size of program headers.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.IElfHeader.ProgramHeaderCount">
            <summary>
            The count of program headers.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.IElfHeader.SectionHeaderEntrySize">
            <summary>
            The size of section headers.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.IElfHeader.SectionHeaderCount">
            <summary>
            The count of section headers.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.IElfHeader.SectionHeaderStringIndex">
            <summary>
            The section header string index.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.IElfPRStatus">
            <summary>
            An abstraction of the ELF PRStatus view.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.IElfPRStatus.ProcessId">
            <summary>
            The process id associated with this prstatus
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.IElfPRStatus.ThreadId">
            <summary>
            The thread id of this prstatus.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.IElfPRStatus.CopyRegistersAsContext(System.Span{System.Byte})">
             <summary>
             Copies the registers within this prstatus into the Windows _CONTEXT structure for the specified
             architecture.
            
             <see cref="T:Microsoft.Diagnostics.Runtime.Arm64Context"/>
             <see cref="T:Microsoft.Diagnostics.Runtime.RiscV64Context"/>
             <see cref="T:Microsoft.Diagnostics.Runtime.AMD64Context"/>
             <see cref="T:Microsoft.Diagnostics.Runtime.ArmContext"/>
             <see cref="T:Microsoft.Diagnostics.Runtime.X86Context"/>
             </summary>
             <param name="context">A span to copy the context into.  This should generally be one of the predefined *Context structs,
             e.g. <see cref="T:Microsoft.Diagnostics.Runtime.AMD64Context"/>.</param>
             <returns>True if the registers were copied to the context, false otherwise.  Usually a return value of false means that
             <paramref name="context"/> was too small.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.LinuxLiveDataReader">
            <summary>
            A data reader that targets a Linux process.
            The current process must have ptrace access to the target process.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.ElfHeaderType">
            <summary>
            The type of ELF file.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.ElfMachine">
            <summary>
            The ELF machine type
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.ElfNoteType">
            <summary>
            The kind of ELF note.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.ElfProgramHeaderType">
            <summary>
            The type of program header.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.COMCallableIUnknown">
            <summary>
            A class that allows you to build a custom IUnknown based interface to pass as a COM object.
            This class is public to allow others to use this code and not duplicate it, but it is not
            intended for general use.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.COMCallableIUnknown.IUnknownObject">
            <summary>
            Gets the IUnknown pointer to this object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.COMCallableIUnknown.IUnknown">
            <summary>
            Gets the IUnknown VTable for this object.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.COMCallableIUnknown.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.COMCallableIUnknown.AddRef">
            <summary>
            AddRef.
            </summary>
            <returns>The new ref count.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.COMCallableIUnknown.Release">
            <summary>
            Release.
            </summary>
            <returns>The new RefCount.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.COMCallableIUnknown.AddInterface(System.Guid,System.Boolean)">
            <summary>
            Adds an IUnknown based interface to this COM object.
            </summary>
            <param name="guid">The GUID of this interface.</param>
            <param name="validate">Whether or not to validate the delegates that
            used to build this COM interface's methods.</param>
            <returns>A VTableBuilder to construct this interface.  Note that until VTableBuilder.Complete
            is called, the interface will not be registered.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.COMHelper">
            <summary>
            Base class for COM related objects in ClrMD.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.COMHelper.Release(System.IntPtr)">
            <summary>
            Release an IUnknown pointer.
            </summary>
            <param name="pUnk">A pointer to the IUnknown interface to release.</param>
            <returns>The result of pUnk->Release().</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.HResult.op_Implicit(Microsoft.Diagnostics.Runtime.Utilities.HResult)~System.Int32">
            <summary>
            Helper to convert to int for comparisons.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.HResult.op_Implicit(Microsoft.Diagnostics.Runtime.Utilities.HResult)~System.Boolean">
            <summary>
            This makes "if (hr)" equivalent to SUCCEEDED(hr).
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.IUnknownVTable">
            <summary>
            The basic VTable for an IUnknown interface.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.VTableBuilder">
            <summary>
            Builds an individual VTable for a COM object.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.VTableBuilder.AddMethod(System.Delegate,System.Boolean)">
            <summary>
            Adds a method to be the next function in the VTable.
            </summary>
            <param name="validate">Whether to validate the delegate matches requirements.</param>
            <param name="func">The function to add to the next slot of the VTable.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.VTableBuilder.Complete">
            <summary>
            Completes the VTable, registering its GUID with the associated COMCallableIUnknown's QueryInterface
            method.  Note that if this method is not called, then the COM interface will NOT be registered.
            </summary>
            <returns>A pointer to the interface built.  This pointer has not been AddRef'ed.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.Command">
            <summary>
            Command represents a running of a command lineNumber process.  It is basically
            a wrapper over System.Diagnostics.Process, which hides the complexity
            of System.Diagnostics.Process, and knows how to capture output and otherwise
            makes calling commands very easy.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Command.StartTime">
            <summary>
            Gets the time the process started.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Command.HasExited">
            <summary>
            Gets a value indicating whether the process has exited.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Command.ExitTime">
            <summary>
            Gets the time the processed Exited.  (HasExited should be <see langword="true"/> before calling)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Command.Duration">
            <summary>
            Gets the duration of the command (HasExited should be <see langword="true"/> before calling)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Command.Id">
            <summary>
            Gets the operating system ID for the subprocess.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Command.ExitCode">
            <summary>
            Gets the process exit code for the subprocess.  (HasExited should be <see langword="true"/> before calling)
            Often this does not need to be checked because Command.Run will throw an exception
            if it is not zero.   However it is useful if the CommandOptions.NoThrow property
            was set.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Command.Output">
            <summary>
            Gets the standard output and standard error output from the command.  This
            is accumulated in real time so it can vary if the process is still running.
            This property is NOT available if the CommandOptions.OutputFile or CommandOptions.OutputStream
            is specified since the output is being redirected there.   If a large amount of output is
            expected (> 1Meg), the Run.AddOutputStream(Stream) is recommended for retrieving it since
            the large string is never materialized at one time.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Command.Options">
            <summary>
            Gets that CommandOptions structure that holds all the options that affect
            the running of the command (like Timeout, Input ...)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Command.Run(System.String,Microsoft.Diagnostics.Runtime.Utilities.CommandOptions)">
            <summary>
            Run 'commandLine' as a subprocess and waits for the command to complete.
            Output is captured and placed in the 'Output' property of the returned Command
            structure.
            </summary>
            <param name="commandLine">The command lineNumber to run as a subprocess</param>
            <param name="options">Additional qualifiers that control how the process is run</param>
            <returns>A Command structure that can be queried to determine ExitCode, Output, etc.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Command.#ctor(System.String,Microsoft.Diagnostics.Runtime.Utilities.CommandOptions)">
            <summary>
            Launch a new command and returns the Command object that can be used to monitor
            the result.  It does not wait for the command to complete, however you
            can call 'Wait' to do that, or use the 'Run' or 'RunToConsole' methods. */
            </summary>
            <param name="commandLine">The command lineNumber to run as a subprocess</param>
            <param name="options">Additional qualifiers that control how the process is run</param>
            <returns>A Command structure that can be queried to determine ExitCode, Output, etc.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Command.#ctor(System.String)">
            <summary>
            Create a subprocess to run 'commandLine' with no special options.
            <param name="commandLine">The command lineNumber to run as a subprocess</param>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Command.Wait">
            <summary>
            Wait for a started process to complete (HasExited will be <see langword="true"/> on return)
            </summary>
            <returns>Wait returns that 'this' pointer.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Command.ThrowCommandFailure(System.String)">
            <summary>
            Throw a error if the command exited with a non-zero exit code
            printing useful diagnostic information along with the thrown message.
            This is useful when NoThrow is specified, and after post-processing
            you determine that the command really did fail, and an normal
            Command.Run failure was the appropriate action.
            </summary>
            <param name="message">An additional message to print in the throw.</param>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Command.Process">
            <summary>
            Gets the underlying process object.  Generally not used.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Command.Kill">
            <summary>
            Kill the process (and any child processes (recursively) associated with the
            running command).   Note that it may not be able to kill everything it should
            if the child-parent' chain is broken by a child that creates a subprocess and
            then dies itself.   This is reasonably uncommon, however.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Command.Quote(System.String)">
            <summary>
            Put double quotes around 'str' if necessary (handles quotes quotes).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Command.FindOnPath(System.String)">
            <summary>
            Given a string 'commandExe' look for it on the path the way cmd.exe would.
            Returns <see langword="null"/> if it was not found.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions">
            <summary>
            CommandOptions is a helper class for the Command class.  It stores options
            that affect the behavior of the execution of ETWCommands and is passes as a
            parameter to the constructor of a Command.
            It is useful for these options be on a separate class (rather than
            on Command itself), because it is reasonably common to want to have a set
            of options passed to several commands, which is not easily possible otherwise.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.Infinite">
            <summary>
            Can be assigned to the Timeout Property to indicate infinite timeout.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.#ctor">
            <summary>
            CommanOptions holds a set of options that can be passed to the constructor
            to the Command Class as well as Command.Run*.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.Clone">
            <summary>
            Return a copy an existing set of command options.
            </summary>
            <returns>The copy of the command options.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.NoThrow">
            <summary>
            Normally commands will throw if the subprocess returns a non-zero
            exit code.  NoThrow suppresses this.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddNoThrow">
            <summary>
            Updates the NoThrow property and returns the updated commandOptions.
            <returns>Updated command options</returns>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.Start">
            <summary>
            ShortHand for UseShellExecute and NoWait.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddStart">
            <summary>
            Updates the Start property and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.UseShellExecute">
            <summary>
            Normally commands are launched with CreateProcess.  However it is
            also possible use the Shell Start API.  This causes Command to look
            up the executable differently.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddUseShellExecute">
            <summary>
            Updates the Start property and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.NoWindow">
            <summary>
            Indicates that you want to hide any new window created.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddNoWindow">
            <summary>
            Updates the NoWindow property and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.NoWait">
            <summary>
            Indicates that you want don't want to wait for the command to complete.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddNoWait">
            <summary>
            Updates the NoWait property and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.Elevate">
            <summary>
            Gets or sets a value indicating whether the command must run at elevated Windows privileges (causes a new command window).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddElevate">
            <summary>
            Updates the Elevate property and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.Timeout">
            <summary>
            By default commands have a 10 minute timeout (600,000 msec), If this
            is inappropriate, the Timeout property can change this.  Like all
            timeouts in .NET, it is in units of milliseconds, and you can use
            CommandOptions.Infinite to indicate no timeout.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddTimeout(System.Int32)">
            <summary>
            Updates the Timeout property and returns the updated commandOptions.
            CommandOptions.Infinite can be used for infinite.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.Input">
            <summary>
            Indicates the string will be sent to Console.In for the subprocess.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddInput(System.String)">
            <summary>
            Updates the Input property and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.CurrentDirectory">
            <summary>
            Indicates the current directory the subProcess will have.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddCurrentDirectory(System.String)">
            <summary>
            Updates the CurrentDirectory property and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.OutputFile">
            <summary>
            Indicates the standard output and error of the command should be redirected
            to a archiveFile rather than being stored in Memory in the 'Output' property of the
            command.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddOutputFile(System.String)">
            <summary>
            Updates the OutputFile property and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.OutputStream">
            <summary>
            Indicates the standard output and error of the command should be redirected
            to a a TextWriter rather than being stored in Memory in the 'Output' property
            of the command.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddOutputStream(System.IO.TextWriter)">
            <summary>
            Updates the OutputStream property and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.EnvironmentVariables">
            <summary>
            Gets the Environment variables that will be set in the subprocess that
            differ from current process's environment variables.  Any time a string
            of the form %VAR% is found in a value of a environment variable it is
            replaced with the value of the environment variable at the time the
            command is launched.  This is useful for example to update the PATH
            environment variable eg. "%PATH%;someNewPath".
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddEnvironmentVariable(System.String,System.String)">
            <summary>
            Adds the environment variable with the give value to the set of
            environment variables to be passed to the sub-process and returns the
            updated commandOptions.   Any time a string
            of the form %VAR% is found in a value of a environment variable it is
            replaced with the value of the environment variable at the time the
            command is launched.  This is useful for example to update the PATH
            environment variable eg. "%PATH%;someNewPath".
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.FileVersionInfo">
            <summary>
            FileVersionInfo represents the extended version formation that is optionally placed in the PE file resource area.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.FileVersionInfo.FileVersion">
            <summary>
            Gets the version string
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.FileVersionInfo.Version">
            <summary>
            Gets the version of this module
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.FileVersionInfo.Comments">
            <summary>
            Gets comments to supplement the file version
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.ImageResourceDataEntry">
            <summary>
            Each resource data entry describes a leaf node in the resource directory
            tree.  It contains an offset, relative to the beginning of the resource
            directory of the data for the resource, a size field that gives the number
            of bytes of data at that offset, a CodePage that should be used when
            decoding code point values within the resource data.  Typically for new
            applications the code page would be the Unicode code page.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.IMAGE_RESOURCE_DIRECTORY">
            <summary>
            Resource directory consists of two counts, following by a variable length
            array of directory entries.  The first count is the number of entries at
            beginning of the array that have actual names associated with each entry.
            The entries are in ascending order, case insensitive strings.  The second
            count is the number of entries that immediately follow the named entries.
            This second count identifies the number of entries that have 16-bit integer
            Ids as their name.  These entries are also sorted in ascending order.
            This structure allows fast lookup by either name or number, but for any
            given resource entry only one form of lookup is supported, not both.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.ImageResourceDirectoryEntry">
            <summary>
            Each directory contains the 32-bit Name of the entry and an offset,
            relative to the beginning of the resource directory of the data associated
            with this directory entry.  If the name of the entry is an actual text
            string instead of an integer Id, then the high order bit of the name field
            is set to one and the low order 31-bits are an offset, relative to the
            beginning of the resource directory of the string, which is of type
            IMAGE_RESOURCE_DIRECTORY_STRING.  Otherwise the high bit is clear and the
            low-order 16-bits are the integer Id that identify this resource directory
            entry. If the directory entry is yet another resource directory (i.e. a
            subdirectory), then the high order bit of the offset field will be
            set to indicate this.  Otherwise the high bit is clear and the offset
            field points to a resource data entry.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.PEImage">
            <summary>
            A class to read information out of PE images (dll/exe).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.PEImage.#ctor(System.IO.Stream,System.Boolean,System.Boolean,System.UInt64)">
            <summary>
            Constructs a PEImage class for a given PE image (dll/exe) in memory.
            </summary>
            <param name="stream">A Stream that contains a PE image at its 0th offset.  This stream must be seekable.</param>
            <param name="leaveOpen">Whether or not to leave the stream open, if this is set to false stream will be
            disposed when this object is.</param>
            <param name="isVirtual">Whether stream points to a PE image mapped into an address space (such as in a live process or crash dump).</param>
            <param name="loadedImageBase">Provide a loaded image base so that the read API based on virtual addresses can be relocated</param>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEImage.Resources">
            <summary>
            Gets the root resource node of this PEImage.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEImage.IsValid">
            <summary>
            Gets a value indicating whether the given Stream contains a valid DOS header and PE signature.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEImage.IsPE64">
            <summary>
            Gets a value indicating whether this image is for a 64bit processor.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEImage.IsManaged">
            <summary>
            Gets a value indicating whether this image is managed. (.NET image)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEImage.IndexTimeStamp">
            <summary>
            Gets the timestamp that this PE image is indexed under.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEImage.IndexFileSize">
            <summary>
            Gets the file size that this PE image is indexed under.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEImage.Pdbs">
            <summary>
            Gets a list of PDBs associated with this PE image.  PE images can contain multiple PDB entries,
            but by convention it's usually the last entry that is the most up to date.  Unless you need to enumerate
            all PDBs for some reason, you should use DefaultPdb instead.
            Undefined behavior if IsValid is <see langword="false"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEImage.DefaultPdb">
            <summary>
            Gets the PDB information for this module.  If this image does not contain PDB info (or that information
            wasn't included in Stream) this returns <see langword="null"/>.  If multiple PDB streams are present, this method returns the
            last entry.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.PEImage.RvaToOffset(System.Int32)">
            <summary>
            Allows you to convert between a virtual address to a stream offset for this module.
            </summary>
            <param name="virtualAddress">The address to translate.</param>
            <returns>The position in the stream of the data, -1 if the virtual address doesn't map to any location of the PE image.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.PEImage.Read(System.Int32,System.Span{System.Byte})">
            <summary>
            Reads data out of PE image into a native buffer.
            </summary>
            <param name="virtualAddress">The address to read from.</param>
            <param name="dest">The location to write the data.</param>
            <returns>The number of bytes actually read from the image and written to dest.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.PEImage.GetFileVersionInfo">
            <summary>
            Gets the File Version Information that is stored as a resource in the PE file.  (This is what the
            version tab a file's property page is populated with).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.PEImage.TryGetExportSymbol(System.String,System.UInt64@)">
            <summary>
            Returns the address of a module export symbol if found
            </summary>
            <param name="symbolName">symbol name (without the module name prepended)</param>
            <param name="offset">symbol offset returned</param>
            <returns>true if found</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.ResourceEntry">
            <summary>
            An entry in the resource table.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ResourceEntry.MaxChildrenCount">
            <summary>
            The maximum number of children nodes that ResourceEntry objects will consider.  Note that if a PEImage is
            corrupted or if we read bad data out of the target then we may misinterpret the data we read and spend
            a lot of time enumerating bad resources.  Setting this to int.MaxValue removes this limitation.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ResourceEntry.MaxNameLength">
            <summary>
            The maximum length ResourceEntry.Name strings we will return.  Note that if a PEImage is
            corrupted or if we read bad data out of the target then we may misinterpret the data we read and spend
            a lot of time enumerating bad resources.  Setting this to int.MaxValue removes this limitation.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ResourceEntry.Image">
            <summary>
            Gets the PEImage containing this ResourceEntry.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ResourceEntry.Parent">
            <summary>
            Gets the parent resource of this ResourceEntry.  Null if and only if this is the root node.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ResourceEntry.Name">
            <summary>
            Gets resource Name.  May be <see langword="null"/> if this is the root node.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ResourceEntry.IsLeaf">
            <summary>
            Gets a value indicating whether this is a leaf, and contains data.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ResourceEntry.Size">
            <summary>
            Gets the size of data for this node.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ResourceEntry.ChildCount">
            <summary>
            Gets the number of children this entry contains.  Note that ResourceEntry.Children is capped at
            MaxChildrenCount entries.  This property returns the total number of entries as defined by the
            IMAGE_RESOURCE_DIRECTORY.  That means this number may be larger than Children.Count.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.ResourceEntry.GetChild(System.String)">
            <summary>
            Returns the given resource child by name.
            </summary>
            <param name="name">The name of the child to return.</param>
            <returns>The child in question, or <see langword="null"/> if none are found with that name.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.ResourceEntry.Read(System.Span{System.Byte},System.Int32)">
            <summary>
            The data associated with this entry.
            </summary>
            <returns>A byte array of the data, or a byte[] of length 0 if this entry contains no data.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.ResourceEntry.Read``1(System.Int32)">
            <summary>
            A convenience function to get structured data out of this entry.
            </summary>
            <typeparam name="T">A struct type to convert.</typeparam>
            <param name="offset">The offset into the data.</param>
            <returns>The struct that was read out of the data section.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ResourceEntry.Children">
            <summary>
            Gets the children resources of this ResourceEntry.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.MemoryRange">
            <summary>
            Represents a range of memory in the target process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.MemoryRange.CreateFromLength(System.UInt64,System.UInt64)">
            <summary>
            Creates a memory range from an address and its length.
            </summary>
            <param name="start">The start address.</param>
            <param name="length">The length of the range.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.MemoryRange.#ctor(System.UInt64,System.UInt64)">
            <summary>
            Constructor.
            </summary>
            <param name="start">The start of the memory range.</param>
            <param name="end">The end of the memory range.</param>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.MemoryRange.Start">
            <summary>
            The inclusive start address of the memory range.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.MemoryRange.End">
            <summary>
            The exclusive end address of the memory range.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.MemoryRange.Length">
            <summary>
            The length of the memory range in bytes.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.MemoryRange.Contains(System.UInt64)">
            <summary>
            Returns whether the memory range contains the given address.
            </summary>
            <param name="address">The address to check.</param>
            <returns>True if the memory range contains the given address.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.MemoryRange.Overlaps(Microsoft.Diagnostics.Runtime.MemoryRange)">
            <summary>
            Returns whether this memory range and <paramref name="other"/> contains any addresses which
            overlap.
            </summary>
            <param name="other">The other memory range to compare this to.</param>
            <returns>True if memory ranges overlap at all.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.MemoryRange.Contains(Microsoft.Diagnostics.Runtime.MemoryRange)">
            <summary>
            Returns whether this memory range contains all of <paramref name="other"/>.
            </summary>
            <param name="other">The other memory range to compare this to.</param>
            <returns>True if this memory range completely encloses <paramref name="other"/>.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.MemoryRange.ToString">
            <summary>
            Returns the range of memory in interval form, ie [start,end).  Since End is not inclusive, we use ')' to denote
            that the range does not include that address.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.MemoryRange.CompareTo(System.UInt64)">
            <summary>
            CompareTo implementation for a single address.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.MethodCompilationType">
            <summary>
            The way a method was JIT'ed.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.MethodCompilationType.None">
            <summary>
            Method is not yet JITed and no NGEN image exists.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.MethodCompilationType.Jit">
            <summary>
            Method was JITed.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.MethodCompilationType.Ngen">
            <summary>
            Method was NGEN'ed (pre-JITed).
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ModuleInfo">
            <summary>
            Provides information about loaded modules in a <see cref="T:Microsoft.Diagnostics.Runtime.DataTarget"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ModuleInfo.TryCreate(Microsoft.Diagnostics.Runtime.IDataReader,System.UInt64,System.String)">
            <summary>
            Attempts to create a <see cref="T:Microsoft.Diagnostics.Runtime.ModuleInfo"/> object from a data reader and a base address.
            This function returns <see langword="null"/> if an image was not found at that address or if
            we could not determine the format of that image.
            </summary>
            <param name="reader">The data reader to create this module from.</param>
            <param name="baseAddress">The base address of this module.</param>
            <param name="name">The name of the module.</param>
            <returns>A constructed ModuleInfo, or null.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ModuleInfo.TryCreate(Microsoft.Diagnostics.Runtime.IDataReader,System.UInt64,System.String,System.Int32,System.Int32,System.Version)">
            <summary>
            Attempts to create a <see cref="T:Microsoft.Diagnostics.Runtime.ModuleInfo"/> object from a data reader and a base address.
            This function returns <see langword="null"/> if an image was not found at that address or if
            we could not determine the format of that image.  This overload allows manually setting the
            file size and timestamp.
            </summary>
            <param name="reader">The data reader to create this module from.</param>
            <param name="baseAddress">The base address of this module.</param>
            <param name="name">The name of the module.</param>
            <param name="indexFileSize">The file size of this module.</param>
            <param name="indexTimeStamp">The timestamp of this module (for PE Images).</param>
            <param name="version">The version of the module.</param>
            <returns>A constructed ModuleInfo, or null.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ModuleInfo.TryCreateResourceRoot(Microsoft.Diagnostics.Runtime.IDataReader,System.UInt64,System.UInt64,System.Boolean)">
            <summary>
            Attempts to create a root resource node for the PE module.
            </summary>
            <param name="reader">The data reader to create this module from.</param>
            <param name="imageBase">The base address of this module.</param>
            <param name="imageSize">The module image size.</param>
            <param name="isFileLayout">if true, the PE has file layout, false loaded layout</param>
            <returns>IResourceNode instance</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.Kind">
            <summary>
            Returns the kind of module this is.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.ImageBase">
            <summary>
            Gets the base address of the this image.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.FileName">
            <summary>
            Retrieves the FileName of this loaded module.  May be empty if it is unknown.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.ImageSize">
            <summary>
            The size of this image (may be different from <see cref="P:Microsoft.Diagnostics.Runtime.ModuleInfo.IndexFileSize"/>).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.IndexFileSize">
            <summary>
            Gets the specific file size of the image used to index it on the symbol server.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.IndexTimeStamp">
            <summary>
            Gets the timestamp of the image used to index it on the symbol server.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.Version">
            <summary>
            The version of this module.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.BuildId">
            <summary>
            Gets the Linux BuildId or Mach-O UUID of this module.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.Pdb">
            <summary>
            Gets the PDB associated with this module.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.IsManaged">
            <summary>
            Gets a value indicating whether the module is managed.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.ResourceRoot">
            <summary>
            The root of the resource tree for this module if one exists, null otherwise.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ModuleKind">
            <summary>
            The kind of module a <see cref="T:Microsoft.Diagnostics.Runtime.ModuleInfo"/> represents.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ModuleKind.Unknown">
            <summary>
            Default value, should not be returned.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ModuleKind.Other">
            <summary>
            This module is not one of the other well defined types but isn't a part of this enum.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ModuleKind.PortableExecutable">
            <summary>
            A Windows PortableExecutable file.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ModuleKind.Elf">
            <summary>
            An Elf image (usually Linux).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ModuleKind.MachO">
            <summary>
            An OS X Mach-O image.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.NativeHeapKind">
            <summary>
            The kind of native heap.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.NativeHeapKind.Unknown">
            <summary>
            This region of memory is a heap that was allocated by CLR, but we didn't have
            enough information to tell which kind of heap.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.NativeHeapKind.IndirectionCellHeap">
            <summary>
            Indirection cells.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.NativeHeapKind.LookupHeap">
            <summary>
            Lookup stubs.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.NativeHeapKind.ResolveHeap">
            <summary>
            Resolve stubs.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.NativeHeapKind.DispatchHeap">
            <summary>
            Dispatch stubs.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.NativeHeapKind.CacheEntryHeap">
            <summary>
            Resolve cache element entries.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.NativeHeapKind.VtableHeap">
            <summary>
            Vtable-based jump stubs.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.NativeHeapKind.LoaderCodeHeap">
            <summary>
            Loader Codeheaps.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.NativeHeapKind.HostCodeHeap">
            <summary>
            Host Codeheaps.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.NativeHeapKind.StubHeap">
            <summary>
            Stub heap.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.NativeHeapKind.HighFrequencyHeap">
            <summary>
            High frequency heap.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.NativeHeapKind.LowFrequencyHeap">
            <summary>
            Low frequency heap.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.NativeHeapKind.ExecutableHeap">
            <summary>
            Executable heap.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.NativeHeapKind.FixupPrecodeHeap">
            <summary>
            FixupPrecodeHeap
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.NativeHeapKind.NewStubPrecodeHeap">
            <summary>
            NewStubPrecodeHeap
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.NativeHeapKind.ThunkHeap">
            <summary>
            ThunkHeap
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.NativeHeapKind.HandleTable">
            <summary>
            GC Handle table.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.NativeHeapKind.GCBookkeeping">
            <summary>
            GC Bookkeeping regions
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.NativeHeapKind.GCFreeRegion">
            <summary>
            GC segments which is currently unused (but still allocated).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ObjectCorruption.SyncBlockIndex">
            <summary>
            The object's SyncBlock index, only filled for SyncBlock related failures.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ObjectCorruption.ClrSyncBlockIndex">
            <summary>
            The system's expected SyncBlock index for this object.  Only filled for
            SyncBlock related failures.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.PdbInfo">
            <summary>
            Information about a specific PDB instance obtained from a PE image.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.PdbInfo.Guid">
            <summary>
            Gets the Guid of the PDB.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.PdbInfo.Revision">
            <summary>
            Gets the PDB revision.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.PdbInfo.Path">
            <summary>
            Gets the path to the PDB.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.PdbInfo.#ctor(System.String,System.Guid,System.Int32)">
            <summary>
            Creates an instance of the PdbInfo class with the corresponding properties initialized.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.PdbInfo.GetHashCode">
            <summary>
            GetHashCode implementation.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.PdbInfo.Equals(System.Object)">
            <summary>
            Override for Equals.  Returns true if the guid, age, and file names equal.  Note that this compares only the.
            </summary>
            <param name="obj"></param>
            <returns>True if the objects match, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.PdbInfo.ToString">
            <summary>
            To string implementation.
            </summary>
            <returns>Printing friendly version.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.RuntimeCallableWrapper">
            <summary>
            Helper for Runtime Callable Wrapper objects.  (RCWs are COM objects which are exposed to the runtime
            as managed objects.)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RuntimeCallableWrapper.IUnknown">
            <summary>
            Gets the pointer to the IUnknown representing this CCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RuntimeCallableWrapper.VTablePointer">
            <summary>
            Gets the external VTable associated with this RCW.  (It's useful to resolve the VTable as a symbol
            which will tell you what the underlying native type is...if you have the symbols for it loaded).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RuntimeCallableWrapper.RefCount">
            <summary>
            Gets the RefCount of the RCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RuntimeCallableWrapper.Object">
            <summary>
            Gets the managed object associated with this of RCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RuntimeCallableWrapper.IsDisconnected">
            <summary>
            Gets a value indicating whether the RCW is disconnected from the underlying COM type.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RuntimeCallableWrapper.CreatorThreadAddress">
            <summary>
            Gets the thread which created this RCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RuntimeCallableWrapper.WinRTObject">
            <summary>
            Gets the internal WinRT object associated with this RCW (if one exists).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RuntimeCallableWrapper.Interfaces">
            <summary>
            Gets the list of interfaces this RCW implements.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.StringCaching.None">
            <summary>
            Do not cache the value at all.  This will result in drastically lower memory
            usage at the cost of performance.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.StringCaching.Cache">
            <summary>
            Strings will be cached by the objects which hold them.  This will make repeated
            requests to get the same value MUCH faster, but at the cost of holding on to
            extra memory.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.StringCaching.Intern">
            <summary>
            Strings will be cached by the objects which hold them and they will also be
            interned, ensuring that the same string value will not be kept alive by multiple
            objects.  The danger here is that interned strings are never freed until the
            AppDomain they live in is unloaded (or never for .NET Core).  Field names will
            benefit from interning if you read a lot of fields for a lot of types.  It's
            unlikely that method names or type names will benefit from interning unless
            the same types are loaded into multiple AppDomains in the target process.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.SymbolProperties">
            <summary>
            The binary under which the files is archived.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.SymbolProperties.Self">
            <summary>
            The binary is archived under its own properties.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.SymbolProperties.Coreclr">
            <summary>
            The binary is archived under coreclr's properties.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.PlatformFunctions">
            <summary>
            A set of helper functions that are consistently implemented across platforms.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.PlatformFunctions.LoadLibrary(System.String)">
            <param name="libraryPath">The path to the native library to be loaded.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.PlatformFunctions.FreeLibrary(System.IntPtr)">
            <param name="handle">The native library OS handle to be freed.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.PlatformFunctions.GetLibraryExport(System.IntPtr,System.String)">
            <param name="handle">The native library OS handle.</param>
            <param name="name">The name of the exported symbol.</param>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Windows.ArrayPoolBasedCacheEntry">
            <summary>
            Represents heap segment cache entries backed by arrays from ArrayPool{byte}.Shared. This technology is less efficient than the <see cref="T:Microsoft.Diagnostics.Runtime.Windows.AWEBasedCacheEntry"/> but it has upsides
            around not requiring special privileges and mapping in a more granular fashion (4k pages vs 64k pages).
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Windows.AWEBasedCacheEntry">
            <summary>
            Represents heap segment cache entries backed by AWE (Address Windowing Extensions). This technology allows us to read the entirety of the heap data out of the dump (which is very fast disk
            access wise) up front, keep it in physical memory, but only maps those physical memory pages into our VM space as needed, allowing us to control how much memory we use and making 'mapping in'
            very fast(some page table entry work in Windows instead of physically reading the data off of disk). The downside is it requires the user have special privileges as well as it maps data
            in 64k chunks(the VirtualAlloc allocation granularity).
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Windows.CacheEntryBase`1">
            <summary>
            This class acts as the base of the two (ArrayPool and AWE) cache entry types.
            </summary>
            <typeparam name="T">The type of data the cache pages hold</typeparam>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Windows.CacheTechnology.ArrayPool">
            <summary>
            Indicates the cache should operate using the ArrayPool to managed byte[] of memory from the dump heap.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Windows.CacheTechnology.AWE">
            <summary>
            Indicates the cache should operate using AWE (Address Windowing Extensions) to manage memory from the dump heap
            </summary>
            <remarks>NOTE: This option is ONLY possible if the user has the 'Lock Pages in Memory' permission, otherwise we will fall back on using <see cref="F:Microsoft.Diagnostics.Runtime.Windows.CacheTechnology.ArrayPool"/></remarks>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Windows.HeapSegmentCacheEventSource.PageInDataEventStart">
            <summary>
            The event ID for when the cache starts paging in data.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Windows.HeapSegmentCacheEventSource.PageInDataEventFailed">
            <summary>
            The event ID for when the cache failed while paging in data.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Windows.HeapSegmentCacheEventSource.PageInDataEventEnd">
            <summary>
            The event ID for when the cache completes paging in data.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Windows.HeapSegmentCacheEventSource.PageOutDataEventStart">
            <summary>
            The event ID for when the cache starts paging out data.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Windows.HeapSegmentCacheEventSource.PageOutDataEventEnd">
            <summary>
            The event ID for when the cache finishes paging out data.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Windows.HeapSegmentCacheEventSource.Tasks">
            <summary>
            Names of constants in this class make up the middle term in the event name
            E.g.: HeapSegmentCacheProvider/PageInData/Start.
            </summary>
            <remarks>Name of this class is important for EventSource.</remarks>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Windows.HeapSegmentCacheEventSource.Tags">
            <summary>
            Tags describing the event result
            </summary>
            <remarks>Name of this class is important for EventSource.</remarks>
        </member>
    </members>
</doc>
